<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#2563eb">
  <meta name="description" content="Archery scoring and team management tools for OAS">
  <title>OAS Score & Tools</title>

  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">

  <!-- Use compiled Tailwind CSS file (works offline, no CDN dependency) -->
  <link rel="stylesheet" href="css/tailwind-compiled.css">
  <link rel="stylesheet" href="css/unified-scorecard-list.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <script src="js/common.js"></script>
  <script>
    // Initialize dark mode immediately (before DOMContentLoaded) to prevent flash
    // Dark mode preference is set from the home screen (index.html)
    if (typeof initDarkMode === 'function') {
      initDarkMode();
    } else {
      // Fallback if common.js not loaded yet
      (function () {
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
      })();
    }
  </script>
</head>

<body
  class="bg-gray-50 dark:bg-gray-900 min-h-screen flex items-center justify-center p-4 transition-colors duration-200">

  <!-- Version check: if server app version changed, clear cache/session and reload to get latest app + data from MySQL -->
  <script>
    (function () {
      var apiBase = window.location.pathname.replace(/\/[^/]*$/, '') || '';
      if (!apiBase) apiBase = '';
      var healthUrl = (apiBase ? apiBase + '/' : '/') + 'api/v1/health';
      function clearCacheAndSessionOnly() {
        var exactKeys = ['archerList', 'archerListMeta', 'archerListPendingUpserts', 'archerSelfExtId', 'live_updates_config', 'event_entry_code', 'archery_master_list', 'archery_tools_onboarding_complete', 'current_bale_session'];
        var keyPrefixes = ['rankingRound_', 'rankingRound300_', 'event:', 'LiveUpdates:', 'live_updates_session:', 'soloCard_session_', 'cachedRound:', 'coachSession:', 'manualBale:', 'luq:'];
        for (var i = 0; i < localStorage.length; i++) {
          var key = localStorage.key(i);
          if (!key) continue;
          if (exactKeys.indexOf(key) !== -1 || keyPrefixes.some(function (p) { return key.indexOf(p) === 0; })) {
            localStorage.removeItem(key);
          }
        }
        try { sessionStorage.clear(); } catch (e) { }
        if (window.caches && typeof window.caches.keys === 'function') {
          window.caches.keys().then(function (names) {
            return Promise.all(names.map(function (n) { return window.caches.delete(n); }));
          }).catch(function () { });
        }
      }
      function fullRefresh(serverVersion) {
        clearCacheAndSessionOnly();
        if (serverVersion) try { localStorage.setItem('app_version', serverVersion); } catch (e) { }
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.getRegistrations().then(function (regs) {
            regs.forEach(function (r) { r.unregister(); });
            doneReload();
          }).catch(doneReload);
        } else { doneReload(); }
        function doneReload() {
          var path = window.location.pathname || '/';
          window.location.href = path + (path.indexOf('?') === -1 ? '?' : '&') + 'nocache=' + Date.now();
        }
      }
      fetch(healthUrl, { cache: 'no-store' }).then(function (r) { return r.json(); }).then(function (data) {
        var serverVersion = (data && (data.build || data.version)) || '';
        var stored = localStorage.getItem('app_version') || '';
        if (serverVersion && serverVersion !== stored) {
          fullRefresh(serverVersion);
        }
      }).catch(function () { });
    })();
  </script>

  <div class="w-full max-w-md mx-auto flex flex-col min-h-screen pb-[calc(48px+env(safe-area-inset-bottom))]">
    <!-- Header with Dark Mode Toggle -->
    <header class="flex justify-between items-center mb-6">
      <h1 class="text-3xl font-bold text-gray-800 dark:text-white">Archery Tools</h1>
      <button id="dark-mode-toggle"
        class="p-2 rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors duration-200"
        title="Toggle dark mode">
        <i class="fas fa-moon dark:hidden"></i>
        <i class="fas fa-sun hidden dark:inline"></i>
      </button>
    </header>

    <!-- Main Content -->
    <div class="flex-grow space-y-6">
      <!-- User Identity Section - Shows archer picker or profile -->
      <div id="identity-section" class="space-y-3">
        <!-- This will be populated by JavaScript based on state -->
      </div>

      <!-- Open Assignments Section -->
      <!-- Open Assignments Sections -->
      <!-- Ranking Rounds -->
      <div id="ranking-section" class="hidden space-y-3">
        <h2 class="text-xl font-bold text-gray-800 dark:text-white flex items-center">
          <i class="fas fa-trophy mr-2 text-teal-600 dark:text-teal-400"></i>
          Ranking Rounds
        </h2>
        <div id="ranking-assignments-list" class="space-y-2"></div>
      </div>

      <!-- Solo Matches -->
      <div id="solo-section" class="hidden space-y-3">
        <h2 class="text-xl font-bold text-gray-800 dark:text-white flex items-center">
          <i class="fas fa-user-friends mr-2 text-yellow-600 dark:text-yellow-400"></i>
          Solo Matches
        </h2>
        <div id="solo-assignments-list" class="space-y-2"></div>
      </div>

      <!-- Team Matches -->
      <div id="team-section" class="hidden space-y-3">
        <h2 class="text-xl font-bold text-gray-800 dark:text-white flex items-center">
          <i class="fas fa-users mr-2 text-purple-600 dark:text-purple-400"></i>
          Team Matches
        </h2>
        <div id="team-assignments-list" class="space-y-2"></div>
      </div>

      <!-- Recent Activity Section -->
      <div id="recent-activity" class="hidden space-y-3">
        <h2 class="text-xl font-bold text-gray-800 dark:text-white flex items-center">
          <i class="fas fa-history mr-2 text-purple-600 dark:text-purple-400"></i>
          Recent Activity
        </h2>
        <div id="recent-activity-list" class="space-y-2">
          <!-- Recent activity will be populated here -->
        </div>

        <!-- Manage Archers Button - access full archer list for editing -->
        <a href="archer_list.html" id="archer-details-btn"
          class="block w-full px-4 py-3 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-white rounded-lg font-medium transition-colors text-center"
          title="View and manage the archer list">
          <i class="fas fa-users mr-2"></i>Manage Archers
        </a>

        <!-- Main Modules -->
        <div class="grid grid-cols-2 gap-4">
          <a href="ranking_round_300.html" id="ranking-round-link"
            class="block px-4 py-4 bg-teal-600 hover:bg-teal-700 dark:bg-teal-500 dark:hover:bg-teal-600 text-white rounded-lg font-semibold transition-all hover:-translate-y-0.5 shadow-lg text-center"
            title="Score competitive ranking rounds with multiple archers">
            <i class="fas fa-trophy block mb-2 text-xl"></i>Ranking
          </a>
          <a href="solo_card.html"
            class="block px-4 py-4 bg-yellow-500 hover:bg-yellow-600 dark:bg-yellow-400 dark:hover:bg-yellow-500 text-gray-900 rounded-lg font-semibold transition-all hover:-translate-y-0.5 shadow-lg text-center"
            title="Track 1v1 matches (first to 6 set points wins)">
            <i class="fas fa-user-friends block mb-2 text-xl"></i>Solo
          </a>
          <a href="team_card.html"
            class="block px-4 py-4 bg-orange-500 hover:bg-orange-600 dark:bg-orange-400 dark:hover:bg-orange-500 text-gray-900 rounded-lg font-semibold transition-all hover:-translate-y-0.5 shadow-lg text-center"
            title="Score team vs team matches (first to 5 set points wins)">
            <i class="fas fa-users-cog block mb-2 text-xl"></i>Team
          </a>
          <a href="gemini-oneshot.html"
            class="block px-4 py-4 bg-red-600 hover:bg-red-700 dark:bg-red-500 dark:hover:bg-red-600 text-white rounded-lg font-semibold transition-all hover:-translate-y-0.5 shadow-lg text-center"
            title="Practice sessions with arrow grouping analysis">
            <i class="fas fa-bullseye block mb-2 text-xl"></i>Practice
          </a>
        </div>
      </div>

      <!-- Footer -->
      <footer
        class="fixed bottom-0 left-0 right-0 h-[48px] bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 flex items-center px-4 shadow-lg transition-colors duration-200 z-10 safe-area-bottom">
        <a href="index.html"
          class="min-w-[48px] h-[48px] text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white active:bg-gray-100 dark:active:bg-gray-700 rounded-lg transition-colors flex items-center justify-center"
          aria-label="Home">
          <i class="fas fa-home text-2xl"></i>
        </a>
        <div class="flex-1"></div>
        <div class="flex gap-2">
          <a href="coach.html"
            class="px-3 h-[44px] bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-white rounded font-semibold hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors flex items-center justify-center text-sm"
            title="Coach console: events and live scoring">
            <i class="fas fa-chalkboard-teacher mr-1"></i>Coaches
          </a>
          <button id="clear-cache-btn"
            class="px-3 h-[44px] min-h-[44px] min-w-[44px] bg-danger text-white rounded font-semibold hover:bg-red-700 transition-colors flex items-center justify-center text-sm"
            title="Reset data and get latest app. Clears cached archers, events, and scoring sessions. Any unsynced scorecard in progress will be lost.">
            <i class="fas fa-broom mr-1"></i>Reset Data
          </button>
        </div>
      </footer>
    </div>

    <script src="js/common.js"></script>
    <script src="js/archer_module.js"></script>
    <script src="js/unified_scorecard_list.js"></script>
    <script>
      // Inline archer picker state
      let archerPickerVisible = false;
      let archerList = [];
      let filteredArchers = [];

      /**
       * Load archer list from server or localStorage.
       * When cache is empty (e.g. after Reset Data), always fetches fresh from server
       * so "Who Are You" picker shows the latest active archers.
       * @returns {Promise<Array>} Archer list
       */
      async function loadArcherList() {
        const cached = localStorage.getItem('archerList');

        // When cache is empty (e.g. after Reset Data), fetch from server first
        if (!cached || cached === '[]') {
          try {
            const res = await fetch('api/v1/archers');
            if (res.ok) {
              const data = await res.json();
              archerList = (data.archers || []).map(a => ({
                id: a.id,
                extId: a.id,
                first: a.first_name || a.firstName || '',
                last: a.last_name || a.lastName || '',
                school: a.school || '',
                level: a.level || '',
                gender: a.gender || '',
                photoUrl: a.photo_url || a.photoUrl || null,
                nickname: a.nickname || ''
              }));
              localStorage.setItem('archerList', JSON.stringify(archerList));
              filteredArchers = archerList.slice(0, 50);
              return archerList;
            }
          } catch (e) {
            console.warn('[index] Could not fetch archer list from server:', e.message);
          }
        }

        // Use cache: ArcherModule or localStorage
        if (window.ArcherModule && typeof window.ArcherModule.loadList === 'function') {
          try {
            const moduleList = window.ArcherModule.loadList();
            if (moduleList && moduleList.length > 0) {
              archerList = moduleList.map(a => ({
                id: a.id || a.extId,
                extId: a.extId || a.id,
                first: a.first || '',
                last: a.last || '',
                school: a.school || '',
                level: a.level || '',
                gender: a.gender || '',
                photoUrl: a.photoUrl || null,
                nickname: a.nickname || ''
              }));
              filteredArchers = archerList.slice(0, 50);
              return archerList;
            }
          } catch (e) {
            console.log('[index] Could not load from ArcherModule:', e.message);
          }
        }

        if (cached) {
          try {
            archerList = JSON.parse(cached) || [];
          } catch (e) {
            archerList = [];
          }
        }

        filteredArchers = archerList.slice(0, 50);
        return archerList;
      }

      /**
       * Filter archer list based on search query
       */
      function filterArchers(query) {
        if (!query || query.length < 1) {
          filteredArchers = archerList.slice(0, 50);
        } else {
          const q = query.toLowerCase();
          filteredArchers = archerList.filter(a =>
            `${a.first} ${a.last}`.toLowerCase().includes(q) ||
            (a.nickname && a.nickname.toLowerCase().includes(q))
          ).slice(0, 20);
        }
        renderArcherPickerList();
      }

      /**
       * Render just the archer list portion of the picker
       */
      function renderArcherPickerList() {
        const listEl = document.getElementById('archer-picker-list');
        if (!listEl) return;

        if (filteredArchers.length === 0) {
          listEl.innerHTML = `
          <div class="text-center py-4 text-gray-500 dark:text-gray-400">
            <i class="fas fa-search text-2xl mb-2"></i>
            <p class="text-sm">No archers found. Try a different search.</p>
          </div>
        `;
          return;
        }

        listEl.innerHTML = filteredArchers.map(archer => {
          const initials = ((archer.first || '').charAt(0) + (archer.last || '').charAt(0)).toUpperCase();
          const details = [archer.school, archer.level, archer.gender].filter(Boolean).join(' ‚Ä¢ ');

          return `
          <button onclick="selectSelfArcher('${archer.extId || archer.id}')" 
                  class="w-full flex items-center gap-3 p-3 bg-white dark:bg-gray-800 hover:bg-blue-50 dark:hover:bg-gray-700 active:bg-blue-100 dark:active:bg-gray-600 rounded-lg border border-gray-200 dark:border-gray-600 transition-colors text-left">
            <div class="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center flex-shrink-0">
              <span class="text-sm font-bold text-white">${initials}</span>
            </div>
            <div class="flex-1 min-w-0">
              <div class="font-semibold text-gray-900 dark:text-white truncate">${archer.first} ${archer.last}</div>
              ${details ? `<div class="text-xs text-gray-500 dark:text-gray-400 truncate">${details}</div>` : ''}
            </div>
            <i class="fas fa-chevron-right text-gray-400"></i>
          </button>
        `;
        }).join('');
      }

      /**
       * Select an archer as "self"
       */
      async function selectSelfArcher(archerId) {
        const archer = archerList.find(a => (a.extId || a.id) === archerId);
        if (!archer) return;

        // Use ArcherModule to set self (this handles localStorage and consistency)
        if (window.ArcherModule && typeof window.ArcherModule.setSelfExtId === 'function') {
          await window.ArcherModule.setSelfExtId(archerId);
        } else {
          // Fallback to direct localStorage if ArcherModule not available
          localStorage.setItem('archerSelfExtId', archerId);
        }

        // Re-render to show profile view
        renderIdentitySection();

        // Load assignments for the selected archer
        loadOpenAssignments();
        // Load recent activity
        loadRecentActivity();
      }

      /**
       * Render the identity section based on state
       * - No archer selected: Show inline picker
       * - Archer selected: Show profile card
       */
      async function renderIdentitySection() {
        const section = document.getElementById('identity-section');
        if (!section) return;

        // Check if we have a selected archer
        let archer = null;

        // Try ArcherModule first (this is the source of truth)
        if (window.ArcherModule && typeof window.ArcherModule.getSelfArcher === 'function') {
          archer = window.ArcherModule.getSelfArcher();
        }

        // Fallback: Try to find archer by extId from localStorage
        if (!archer) {
          const extId = window.ArcherModule && typeof window.ArcherModule.getSelfExtId === 'function'
            ? window.ArcherModule.getSelfExtId()
            : localStorage.getItem('archerSelfExtId') || '';

          if (extId) {
            // First try ArcherModule list (most reliable)
            if (window.ArcherModule && typeof window.ArcherModule.loadList === 'function') {
              const moduleList = window.ArcherModule.loadList();
              archer = moduleList.find(a => (a.extId === extId || a.id === extId));
            }

            // Fallback to local archerList
            if (!archer && archerList.length > 0) {
              archer = archerList.find(a => (a.extId || a.id) === extId || `${(a.first || '').trim()}-${(a.last || '').trim()}` === extId);
            }
          }
        }

        if (archer) {
          // SELECTED STATE: Show profile card
          const nickname = archer.nickname ? ` "${archer.nickname}"` : '';
          const initials = ((archer.first || '').charAt(0) + (archer.last || '').charAt(0)).toUpperCase();
          const archerId = archer.extId || archer.id || '';

          let avatarHTML = '';
          if (archer.photoUrl) {
            avatarHTML = `<img src="${archer.photoUrl}" alt="${archer.first} ${archer.last}" class="w-16 h-16 rounded-full object-cover border-[3px] border-white dark:border-gray-700 shadow-md">`;
          } else {
            avatarHTML = `<div class="w-16 h-16 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center border-[3px] border-white dark:border-gray-700 shadow-md"><span class="text-xl font-bold text-white">${initials}</span></div>`;
          }

          section.innerHTML = `
          <div class="bg-white dark:bg-gray-800 rounded-xl p-4 shadow-sm border border-gray-200 dark:border-gray-700">
            <div class="flex items-center gap-4">
              ${avatarHTML}
              <div class="flex-1 min-w-0">
                <div class="text-xl font-bold text-gray-900 dark:text-white truncate">${archer.first} ${archer.last}${nickname}</div>
                <div class="text-sm text-gray-500 dark:text-gray-400">${[archer.school, archer.level, archer.gender].filter(Boolean).join(' ‚Ä¢ ') || 'Archer'}</div>
              </div>
              <div class="flex gap-2">
                <a href="archer_history.html?archer=${archerId}" 
                   class="p-2 text-blue-500 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-gray-700 rounded-lg transition-colors" 
                   title="View scoring history">
                  <i class="fas fa-file-alt text-lg"></i>
                </a>
                <button onclick="showArcherPicker()" 
                        class="p-2 text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors" 
                        title="Switch archer">
                  <i class="fas fa-exchange-alt text-lg"></i>
                </button>
              </div>
            </div>
          </div>
        `;
        } else {
          // NOT SELECTED STATE: Show inline picker
          await loadArcherList();

          section.innerHTML = `
          <div class="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
            <!-- Header -->
            <div class="bg-gradient-to-r from-blue-600 to-blue-700 dark:from-blue-700 dark:to-blue-800 px-4 py-4 text-white">
              <h2 class="text-lg font-bold flex items-center gap-2">
                <i class="fas fa-user-circle"></i>
                Who are you?
              </h2>
              <p class="text-sm text-blue-100 mt-1">Select your name to get started</p>
            </div>
            
            <!-- Search -->
            <div class="p-3 border-b border-gray-200 dark:border-gray-600">
              <div class="relative">
                <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                <input type="text" 
                       id="archer-search-input"
                       placeholder="Type your name..." 
                       class="w-full pl-10 pr-4 py-3 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg text-gray-900 dark:text-white placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                       oninput="filterArchers(this.value)">
              </div>
            </div>
            
            <!-- List -->
            <div id="archer-picker-list" class="p-2 max-h-[300px] overflow-y-auto space-y-2 bg-white dark:bg-gray-800">
              <!-- Populated by renderArcherPickerList -->
            </div>
            
            <!-- Footer -->
            <div class="p-3 border-t border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700">
              <div class="flex gap-2">
                <a href="archer_list.html" 
                   class="flex-1 px-4 py-2.5 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-white rounded-lg font-medium text-center hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-sm border border-gray-300 dark:border-gray-600">
                  <i class="fas fa-user-plus mr-1"></i>Add New
                </a>
                <button onclick="skipIdentity()" 
                        class="flex-1 px-4 py-2.5 text-gray-600 dark:text-gray-300 rounded-lg font-medium text-center hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors text-sm">
                  Skip for now
                </button>
              </div>
            </div>
          </div>
        `;

          // Render the initial list
          renderArcherPickerList();
        }
      }

      /**
       * Show the archer picker (for switching archers)
       */
      function showArcherPicker() {
        localStorage.removeItem('archerSelfExtId');
        renderIdentitySection();
      }

      /**
       * Skip identity selection
       */
      function skipIdentity() {
        const section = document.getElementById('identity-section');
        if (section) {
          section.innerHTML = `
          <div class="text-center py-4">
            <button onclick="renderIdentitySection()" 
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-colors">
              <i class="fas fa-user-circle mr-2"></i>Select Yourself
            </button>
          </div>
        `;
        }
      }

      /**
       * Create simplified 2-column assignments list
       * Layout: Assignment (name + details, wide) | Progress (score/sets)
       * Optimized for mobile with larger text and touch targets
       */
      function createAssignmentsList(items, options) {
        const container = document.createElement('div');
        container.className = 'flex flex-col w-full rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700';

        // Header row
        const header = document.createElement('div');
        header.className = 'grid gap-2 px-3 py-2.5 bg-gray-100 dark:bg-gray-700 text-xs font-semibold text-gray-700 dark:text-gray-300 uppercase tracking-wide items-center';
        header.style.gridTemplateColumns = 'minmax(0, 1fr) minmax(80px, auto)';
        header.innerHTML = `
        <div>Assignment</div>
        <div class="text-right">Progress</div>
      `;
        container.appendChild(header);

        // Items
        items.forEach((item, index) => {
          const row = document.createElement('div');
          row.className = 'grid gap-2 px-3 py-3 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-600 items-center cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 active:bg-gray-100 dark:active:bg-gray-600 transition-colors min-h-[60px]';
          row.style.gridTemplateColumns = 'minmax(0, 1fr) minmax(80px, auto)';

          if (options.onItemClick) {
            row.onclick = () => options.onItemClick(item, index);
          }

          // Get values
          const eventName = options.getEventName ? options.getEventName(item) : item.event_name;
          const progress = options.getTotal ? options.getTotal(item) : '';
          const roundType = options.getAvg ? options.getAvg(item) : item.round_type || '';

          // Format date
          let dateStr = '';
          if (item.event_date) {
            const date = new Date(item.event_date);
            if (!isNaN(date.getTime())) {
              dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: '2-digit' });
            }
          }

          // Build subtitle: use custom second line for solo/team (subtitleOverride) or date ‚Ä¢ round ‚Ä¢ division [‚Ä¢ Bale X ‚Ä¢ Target Y]
          let subtitle;
          if (item.subtitleOverride != null) {
            subtitle = String(item.subtitleOverride);
          } else {
            const subtitleParts = [dateStr, roundType, item.division].filter(p => p && p.trim());
            // Append bale/target info for ranking rounds when available
            if (item.bale_number) {
              subtitleParts.push(`Bale ${item.bale_number}`);
              if (item.target_assignment) subtitleParts.push(`Target ${item.target_assignment}`);
            }
            subtitle = subtitleParts.join(' ‚Ä¢ ');
          }

          // Determine progress color based on type
          let progressClass = 'text-blue-600 dark:text-blue-400';
          if (item.isSolo) {
            progressClass = 'text-green-600 dark:text-green-400';
          } else if (item.isBracket) {
            progressClass = 'text-yellow-600 dark:text-yellow-400';
          }

          // Void Button Logic
          let voidBtnHtml = '';
          if (options.canVoid && item.id) {
            // Prevent bubbling
            voidBtnHtml = `
               <button onclick="event.stopPropagation(); voidMatch('${item.id}', '${item.isSolo ? 'solo' : 'team'}')" 
                       class="ml-2 p-2 text-gray-400 hover:text-red-500 transition-colors z-10 relative" 
                       title="Void Match">
                   <i class="fas fa-trash-alt"></i>
               </button>
               `;
          }

          row.innerHTML = `
          <div class="flex flex-col gap-1 min-w-0 overflow-hidden">
            <div class="text-base font-semibold text-gray-900 dark:text-white overflow-hidden text-ellipsis whitespace-nowrap leading-tight flex items-center gap-2">
                ${eventName}
            </div>
            <div class="text-sm text-gray-600 dark:text-gray-400 overflow-hidden text-ellipsis whitespace-nowrap leading-tight">${subtitle}</div>
          </div>
          <div class="flex items-center justify-end">
              <div class="text-lg font-bold ${progressClass} whitespace-nowrap">${progress}</div>
              ${voidBtnHtml}
          </div>
        `;

          container.appendChild(row);
        });

        return container;
      }

      // Load open assignments for the current archer
      async function loadOpenAssignments() {
        try {
          // Get current archer
          let archer = null;
          if (window.ArcherModule && typeof window.ArcherModule.getSelfArcher === 'function') {
            archer = window.ArcherModule.getSelfArcher();
          }

          if (!archer) {
            console.log('[index] No archer set - cannot load assignments');
            return;
          }

          // Get archer ID - need UUID for history endpoint
          // UUID format: 36 chars with dashes (e.g., "3c7533af-eda1-48c7-b688-3279e75cc697")
          // Check multiple possible ID fields
          let archerId = archer.id || archer.archerId || archer.databaseId || null;
          let isUUID = archerId && archerId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);

          console.log('[index] Archer object:', {
            first: archer.first,
            last: archer.last,
            id: archer.id,
            archerId: archer.archerId,
            databaseId: archer.databaseId,
            extId: archer.extId,
            allKeys: Object.keys(archer)
          });

          // If we don't have a UUID, try to find it by searching
          if (!isUUID && archer.first && archer.last) {
            try {
              console.log('[index] Searching for UUID by name:', archer.first, archer.last);
              const searchRes = await fetch(`api/v1/archers/search?q=${encodeURIComponent(archer.first + ' ' + archer.last)}`);
              if (searchRes.ok) {
                const searchData = await searchRes.json();
                console.log('[index] Search results:', searchData);
                // The search API returns results in a different format
                if (searchData.results && searchData.results.length > 0) {
                  const match = searchData.results.find(r =>
                    r.archer.firstName.toLowerCase() === archer.first.toLowerCase() &&
                    r.archer.lastName.toLowerCase() === archer.last.toLowerCase()
                  );
                  if (match && match.archer.id) {
                    archerId = match.archer.id;
                    isUUID = true;
                    console.log('[index] Found UUID for archer:', archerId);
                  } else {
                    console.log('[index] No exact name match found in search results');
                  }
                } else {
                  console.log('[index] No search results returned');
                }
              } else {
                console.log('[index] Search request failed:', searchRes.status, searchRes.statusText);
              }
            } catch (e) {
              console.log('[index] Could not search for archer UUID:', e.message);
            }
          }

          if (!archerId || !isUUID) {
            console.log('[index] No valid UUID found - cannot load assignments. Final archerId:', archerId, 'isUUID:', isUUID);
            return;
          }

          console.log('[index] Loading assignments for archer UUID:', archerId);

          const assignments = [];
          // Hoisted so renderRecentActivity can access it after the inner try block
          let fullHistory = [];

          // Check for open ranking rounds
          try {
            const historyRes = await fetch(`api/v1/archers/${archerId}/history`);
            console.log('[index] History API response status:', historyRes.status);
            if (historyRes.ok) {
              const historyData = await historyRes.json();
              fullHistory = historyData.history || historyData.rounds || [];
              console.log('[index] History data:', historyData);
              const rounds = fullHistory;
              console.log('[index] Total rounds found:', rounds.length);

              // Separate ranking rounds and solo/team matches
              const rankingRounds = rounds.filter(r => r.type === 'ranking' || !r.type);
              const soloMatches = rounds.filter(r => r.type === 'solo');
              const teamMatches = rounds.filter(r => r.type === 'team');

              // Staleness helper: hide PENDING items with zero progress older than 7 days
              const now = new Date();
              const STALE_DAYS = 7;
              function isStale(eventDate, hasProgress) {
                if (hasProgress) return false; // In-progress work is never stale
                if (!eventDate) return true; // No date = can't determine relevance
                const age = (now - new Date(eventDate)) / (1000 * 60 * 60 * 24);
                return age > STALE_DAYS;
              }

              // Find ranking rounds to show in assignments
              // Show only PENDING (incomplete work) and COMP (completed today)
              // Hide stale assignments (old + zero progress)
              const openRounds = rankingRounds.filter(round => {
                if (!round.round_id) {
                  console.warn('[index] Round missing round_id, skipping:', round);
                  return false;
                }

                const cardStatus = (round.card_status || round.cardStatus || 'PENDING').toUpperCase();
                const endsCompleted = parseInt(round.ends_completed || 0);
                const isToday = round.event_date === new Date().toISOString().slice(0, 10);

                const normalizedStatus = cardStatus === 'PEND' ? 'PENDING' :
                  cardStatus === 'COMP' ? 'COMPLETED' :
                    cardStatus === 'VRFD' ? 'VERIFIED' : cardStatus;

                // Show if PENDING/PEND and not yet complete
                if ((normalizedStatus === 'PENDING' || normalizedStatus === 'PEND') && endsCompleted < 10) {
                  // Hide stale (old + no progress started)
                  if (isStale(round.event_date, endsCompleted > 0)) return false;
                  return true;
                }

                // Show if COMPLETED/COMP and today
                if (normalizedStatus === 'COMPLETED' || normalizedStatus === 'COMP') {
                  return isToday;
                }

                // Don't show VERIFIED/VRFD or VOID
                return false;
              });

              // Find solo matches to show in assignments
              // Show only PENDING/PEND (incomplete work) and COMPLETED/COMP (completed today)
              // Hide stale assignments (old + zero progress)
              const openSoloMatches = soloMatches.filter(match => {
                const cardStatus = (match.card_status || 'PENDING').toUpperCase();
                const isToday = match.event_date === new Date().toISOString().slice(0, 10);
                const setsWon = parseInt(match.sets_won || 0);
                const opponentSetsWon = parseInt(match.opponent_sets_won || 0);
                const isMatchComplete = setsWon >= 6 || opponentSetsWon >= 6;
                const hasProgress = setsWon > 0 || opponentSetsWon > 0;

                const normalizedStatus = cardStatus === 'PEND' ? 'PENDING' :
                  cardStatus === 'COMP' ? 'COMPLETED' :
                    cardStatus === 'VRFD' ? 'VERIFIED' : cardStatus;

                if ((normalizedStatus === 'PENDING' || normalizedStatus === 'PEND') && !isMatchComplete) {
                  if (isStale(match.event_date, hasProgress)) return false;
                  return true;
                }

                if (normalizedStatus === 'COMPLETED' || normalizedStatus === 'COMP') {
                  return isToday;
                }

                return false;
              });

              // Find team matches to show in assignments
              // Show only PENDING (incomplete) and COMP (completed today)
              // Hide stale assignments (old + zero progress)
              const openTeamMatches = teamMatches.filter(match => {
                const cardStatus = (match.card_status || 'PENDING').toUpperCase();
                const isToday = match.event_date === new Date().toISOString().slice(0, 10);
                const setsWon = parseInt(match.sets_won || 0);
                const opponentSetsWon = parseInt(match.opponent_sets_won || 0);
                const isMatchComplete = setsWon >= 5 || opponentSetsWon >= 5;
                const hasProgress = setsWon > 0 || opponentSetsWon > 0;

                const normalizedStatus = cardStatus === 'PEND' ? 'PENDING' :
                  cardStatus === 'COMP' ? 'COMPLETED' :
                    cardStatus === 'VRFD' ? 'VERIFIED' : cardStatus;

                if ((normalizedStatus === 'PENDING' || normalizedStatus === 'PEND') && !isMatchComplete) {
                  if (isStale(match.event_date, hasProgress)) return false;
                  return true;
                }
                if (normalizedStatus === 'COMPLETED' || normalizedStatus === 'COMP') {
                  return isToday;
                }
                return false;
              });

              console.log('[index] Open rounds found:', openRounds.length);
              console.log('[index] Open solo matches found:', openSoloMatches.length);
              console.log('[index] Open team matches found:', openTeamMatches.length);

              // Build links for ranking rounds
              openRounds.forEach(round => {
                const isStarted = (round.ends_completed || 0) > 0;

                // Build link with entry code for standalone rounds
                // For event-linked rounds, entry code will be fetched from event snapshot in handleDirectLink
                // For standalone rounds, include entry code in URL so it works across browser sessions
                const eventParam = round.event_id ? round.event_id : 'null';
                let link = `ranking_round_300.html?event=${eventParam}&round=${round.round_id}&archer=${archerId}`;

                // Include entry_code in URL for standalone rounds (so link works across browser sessions)
                if (round.is_standalone && round.entry_code) {
                  link += `&code=${encodeURIComponent(round.entry_code)}`;
                }

                console.log('[index] Building resume link:', {
                  round_id: round.round_id,
                  event_id: round.event_id,
                  is_standalone: round.is_standalone,
                  entry_code: round.entry_code ? 'present' : 'missing',
                  archerId: archerId,
                  link: link
                });

                // Build event name - always show event name, add "Resume" prefix if in progress
                const eventName = round.event_name || 'Ranking Round';
                const title = isStarted ? `${eventName} - Resume` : eventName;

                // Build bale/target detail string ‚Äî shown on card so archer knows where to go
                let baleDetail = '';
                if (round.bale_number) {
                  baleDetail = `Bale ${round.bale_number}`;
                  if (round.target_assignment) baleDetail += ` ‚Ä¢ Target ${round.target_assignment}`;
                }
                const endsDetail = `${round.ends_completed || 0}/10 ends`;
                const detailParts = [baleDetail, endsDetail].filter(Boolean);

                assignments.push({
                  type: 'ranking',
                  title: title,
                  subtitle: `${round.round_type || 'R300'} ‚Ä¢ ${round.division || 'Unknown Division'}`,
                  details: detailParts.join(' ‚Ä¢ '),
                  link: link,
                  icon: isStarted ? 'fas fa-play-circle' : 'fas fa-trophy',
                  color: isStarted ? 'bg-green-600 hover:bg-green-700' : 'bg-teal-600 hover:bg-teal-700',
                  urgent: isStarted && (round.ends_completed || 0) < 10, // Has started but not finished
                  event_date: round.event_date || round.eventDate || null,
                  card_status: round.card_status || round.cardStatus || 'PENDING',
                  ends_completed: round.ends_completed || 0,
                  round_type: round.round_type || 'R300',
                  bale_number: round.bale_number || null,
                  target_assignment: round.target_assignment || null
                });
              });

              // Build links for solo matches
              openSoloMatches.forEach(match => {
                const setsWon = parseInt(match.sets_won || 0);
                const opponentSetsWon = parseInt(match.opponent_sets_won || 0);
                const isStarted = setsWon > 0 || opponentSetsWon > 0;
                const isComplete = setsWon >= 6 || opponentSetsWon >= 6;

                // Build link to solo card with match ID
                const link = `solo_card.html?match=${match.match_id}`;

                // Build event name
                const eventName = match.event_name || 'Solo Match';
                const title = isStarted ? (isComplete ? `${eventName} - View` : `${eventName} - Resume`) : eventName;

                assignments.push({
                  type: 'solo',
                  title: title,
                  subtitle: `vs ${match.opponent_name || 'Opponent'}`,
                  details: `Sets: ${setsWon}-${opponentSetsWon}${match.is_winner ? ' üèÜ' : ''}`,
                  link: link,
                  icon: isComplete ? 'fas fa-trophy' : (isStarted ? 'fas fa-play-circle' : 'fas fa-user-friends'),
                  color: isComplete ? 'bg-yellow-500 hover:bg-yellow-600' : (isStarted ? 'bg-green-600 hover:bg-green-700' : 'bg-yellow-500 hover:bg-yellow-600'),
                  urgent: isStarted && !isComplete,
                  event_date: match.event_date || null,
                  card_status: match.card_status || 'PENDING',
                  match_id: match.match_id,
                  opponent_name: match.opponent_name,
                  sets_won: setsWon,
                  opponent_sets_won: opponentSetsWon,
                  is_winner: match.is_winner
                });
              });

              // Build links for team matches
              openTeamMatches.forEach(match => {
                const setsWon = parseInt(match.sets_won || 0);
                const opponentSetsWon = parseInt(match.opponent_sets_won || 0);
                const isStarted = setsWon > 0 || opponentSetsWon > 0;
                const isComplete = setsWon >= 5 || opponentSetsWon >= 5;

                const link = `team_card.html?match=${match.match_id}`;

                const eventName = match.event_name || 'Team Match';
                const title = isStarted ? (isComplete ? `${eventName} - View` : `${eventName} - Resume`) : eventName;
                const oppTeam = match.opponent_team || 'Opponent';

                assignments.push({
                  type: 'team',
                  isTeam: true,
                  title: title,
                  subtitle: `${match.team_name || '?'} vs ${oppTeam}`,
                  details: `Sets: ${setsWon}-${opponentSetsWon}${match.is_winner ? ' üèÜ' : ''}`,
                  link: link,
                  icon: isComplete ? 'fas fa-trophy' : (isStarted ? 'fas fa-play-circle' : 'fas fa-users'),
                  color: isComplete ? 'bg-orange-500 hover:bg-orange-600' : (isStarted ? 'bg-green-600 hover:bg-green-700' : 'bg-orange-500 hover:bg-orange-600'),
                  urgent: isStarted && !isComplete,
                  event_date: match.event_date || null,
                  card_status: match.card_status || 'PENDING',
                  match_id: match.match_id,
                  event_name: title,
                  team_name: match.team_name,
                  opponent_team: oppTeam,
                  sets_won: setsWon,
                  opponent_sets_won: opponentSetsWon,
                  is_winner: match.is_winner
                });
              });
            }
          } catch (e) {
            console.log('Could not load ranking round history:', e.message);
          }

          // Check for bracket assignments - use efficient single-query endpoint
          try {
            console.log('[index] Checking for bracket assignments...');
            const bracketRes = await fetch(`api/v1/archers/${archerId}/bracket-assignments`);

            if (bracketRes.ok) {
              const bracketData = await bracketRes.json();
              const bracketAssignments = bracketData.assignments || [];
              console.log('[index] Bracket assignments found:', bracketAssignments.length);

              // Add each bracket assignment (Swiss solo)
              bracketAssignments.forEach(assignment => {
                if (assignment.bracket_type === 'SOLO') {
                  if (assignment.bracket_format === 'ELIMINATION' && assignment.opponent) {
                    // Elimination bracket with assigned opponent
                    assignments.push({
                      type: 'bracket',
                      title: `${assignment.division} Elimination Bracket`,
                      subtitle: `${assignment.event_name || 'Event'} ‚Ä¢ ${assignment.round}`,
                      details: `You (Seed ${assignment.seed}) vs ${assignment.opponent.name} (Seed ${assignment.opponent.seed})`,
                      link: `solo_card.html?event=${assignment.event_id}&bracket=${assignment.bracket_id}`,
                      icon: 'fas fa-trophy',
                      color: 'bg-yellow-500 hover:bg-yellow-600',
                      urgent: true,
                      matchId: assignment.match_id,
                      event_date: assignment.event_date
                    });
                  } else if (assignment.bracket_format === 'SWISS') {
                    // Swiss bracket - dedupe with history solo (same match can appear in both APIs)
                    const matchId = assignment.match_id;
                    let mergedSets = { sets_won: 0, opponent_sets_won: 0, is_winner: false };
                    const existingIdx = assignments.findIndex(a =>
                      (a.type === 'solo' || a.type === 'bracket') &&
                      (a.match_id === matchId || a.matchId === matchId)
                    );
                    if (existingIdx >= 0) {
                      const existing = assignments.splice(existingIdx, 1)[0];
                      mergedSets = {
                        sets_won: existing.sets_won ?? 0,
                        opponent_sets_won: existing.opponent_sets_won ?? 0,
                        is_winner: !!existing.is_winner
                      };
                    }

                    const winLoss = assignment.swiss_wins || 0;
                    const losses = assignment.swiss_losses || 0;
                    const record = `${winLoss}-${losses}`;
                    const oppFirst = (assignment.opponent_name || '').split(/\s+/)[0] || 'Opponent';

                    let baleInfo = '';
                    if (assignment.bale_number) {
                      baleInfo = `Bale ${assignment.bale_number}`;
                      if (assignment.my_target) baleInfo += `, Target ${assignment.my_target}`;
                      if (assignment.line_number) baleInfo += `, Line ${assignment.line_number}`;
                      if (assignment.wave) baleInfo += ` (Wave ${assignment.wave})`;
                    }

                    const setsWon = mergedSets.sets_won;
                    const oppSetsWon = mergedSets.opponent_sets_won;
                    const setsStr = `Sets: ${setsWon}-${oppSetsWon}`;
                    const trophyIcon = mergedSets.is_winner ? ' üèÜ' : '';

                    const eventName = assignment.event_name || 'Event';
                    const bracketName = assignment.round || assignment.current_round || 'Solo';
                    const title = `${eventName} - ${bracketName}`;
                    const details = baleInfo
                      ? `${oppFirst}: ${record} | ${baleInfo}`
                      : `${oppFirst}: ${record}`;

                    const matchLink = matchId
                      ? `solo_card.html?match=${matchId}`
                      : `solo_card.html?event=${assignment.event_id}&bracket=${assignment.bracket_id}`;

                    assignments.push({
                      type: 'bracket',
                      title,
                      subtitle: details,
                      details: setsStr + trophyIcon,
                      link: matchLink,
                      icon: mergedSets.is_winner ? 'fas fa-trophy' : (assignment.bale_number ? 'fas fa-bullseye' : 'fas fa-trophy'),
                      color: assignment.match_id ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-500 hover:bg-blue-600',
                      urgent: !!assignment.match_id,
                      event_date: assignment.event_date,
                      matchId: matchId,
                      match_id: matchId,
                      baleNumber: assignment.bale_number,
                      lineNumber: assignment.line_number,
                      myTarget: assignment.my_target,
                      wave: assignment.wave,
                      sets_won: setsWon,
                      opponent_sets_won: oppSetsWon,
                      is_winner: mergedSets.is_winner,
                      event_name: title,
                      opponent_name: assignment.opponent_name
                    });
                  }
                }
              });
            } else if (bracketRes.status !== 404) {
              // 404 means no assignments - that's fine, don't log
              console.warn('[index] Error loading bracket assignments:', bracketRes.status);
            }
          } catch (e) {
            console.log('Could not load bracket assignments:', e.message);
          }

          // NOTE: Removed "Active Event" links section
          // These links only had event ID, missing round and archer parameters
          // This caused wrong archer to load (used stale cookie instead of URL param)
          // "Resume Ranking Round" links (above) already show active rounds with complete parameters

          // Display assignments in split sections
          const rankingSection = document.getElementById('ranking-section');
          const rankingList = document.getElementById('ranking-assignments-list');
          const soloSection = document.getElementById('solo-section');
          const soloList = document.getElementById('solo-assignments-list');
          const teamSection = document.getElementById('team-section');
          const teamList = document.getElementById('team-assignments-list');

          // Reset all
          if (rankingSection) rankingSection.classList.add('hidden');
          if (soloSection) soloSection.classList.add('hidden');
          if (teamSection) teamSection.classList.add('hidden');
          if (rankingList) rankingList.innerHTML = '';
          if (soloList) soloList.innerHTML = '';
          if (teamList) teamList.innerHTML = '';

          // Render Recent Activity first ‚Äî before any early return ‚Äî so archers
          // with no open assignments still see their history, and switching archers
          // clears stale data from the previous selection.
          renderRecentActivity(fullHistory, archerId);

          if (assignments.length === 0) {
            return;
          }

          // Sort by urgency (urgent first)
          assignments.sort((a, b) => (b.urgent ? 1 : 0) - (a.urgent ? 1 : 0));

          // Bucket assignments
          const rankingItems = assignments.filter(a => a.type === 'ranking');
          const soloItems = assignments.filter(a => a.type === 'solo' || (a.type === 'bracket' && !a.isTeam));
          // Note: isTeam needs to be set if we have team brackets. Currently assuming bracket defaults to solo.
          const teamItems = assignments.filter(a => a.type === 'team' || (a.type === 'bracket' && a.isTeam));

          // Helper to create list options
          const createOptions = (isMatch) => ({
            columns: ['Assignment', 'Progress'],
            twoColumnLayout: true,
            onItemClick: (item) => window.location.href = item.link,
            getEventName: (item) => item.event_name,
            getTotal: (item) => {
              if (item.isBracket) return item.ends_completed;
              if (item.isSolo) return item.ends_completed;
              if (item.isTeam) return item.ends_completed;
              return `${item.ends_completed}/10`; // Ranking
            },
            getAvg: (item) => item.round_type,
            canVoid: isMatch // Enable void for matches
          });

          // Render Ranking
          if (rankingItems.length > 0 && rankingList) {
            const items = rankingItems.map(a => ({
              event_name: a.title,
              event_date: a.event_date,
              round_type: a.round_type || 'Ranking',
              division: (a.subtitle || '').split(' ‚Ä¢ ')[1] || '',
              link: a.link,
              ends_completed: a.ends_completed || 0,
              bale_number: a.bale_number || null,
              target_assignment: a.target_assignment || null,
              id: a.match_id || a.round_id
            }));
            rankingList.appendChild(createAssignmentsList(items, createOptions(false)));
            rankingSection.classList.remove('hidden');
          }

          // Render Solo ‚Äî consistent label: event name, then "vs Opponent" subtitle
          if (soloItems.length > 0 && soloList) {
            const items = soloItems.map(a => {
              const eventName = a.event_name || a.title;
              const progress = a.details || (a.sets_won != null ? `Sets: ${a.sets_won}-${a.opponent_sets_won || 0}${a.is_winner ? ' üèÜ' : ''}` : '0-0');
              // Consistent subtitle: always "vs [Opponent]" for solo matches
              let subtitleOverride = null;
              if (a.type === 'bracket' && a.subtitle) {
                subtitleOverride = a.subtitle; // Swiss bracket already has formatted subtitle
              } else if (a.opponent_name) {
                subtitleOverride = `vs ${a.opponent_name}`;
              } else if (a.subtitle) {
                subtitleOverride = a.subtitle;
              }

              return {
                event_name: eventName,
                event_date: a.event_date,
                round_type: 'Solo',
                division: '',
                subtitleOverride,
                link: a.link,
                ends_completed: progress,
                isSolo: true,
                isBracket: a.type === 'bracket',
                id: a.match_id || a.matchId
              };
            });
            soloList.appendChild(createAssignmentsList(items, createOptions(true)));
            soloSection.classList.remove('hidden');
          }

          // Render Team ‚Äî consistent label: event name, then "[My Team] vs [Opponent]" subtitle
          if (teamItems.length > 0 && teamList) {
            const items = teamItems.map(a => {
              const progress = a.details || (a.sets_won != null ? `Sets: ${a.sets_won}-${a.opponent_sets_won || 0}${a.is_winner ? ' üèÜ' : ''}` : '0-0');
              const oppTeam = a.opponent_team || 'Opponent';
              const myTeam = a.team_name || 'Team';
              // Consistent subtitle: "[My Team] vs [Opponent]"
              const subtitleOverride = `${myTeam} vs ${oppTeam}`;

              return {
                event_name: a.event_name || a.title,
                event_date: a.event_date,
                round_type: 'Team',
                division: '',
                subtitleOverride,
                link: a.link,
                ends_completed: progress,
                isTeam: true,
                id: a.match_id || a.matchId
              };
            });
            teamList.appendChild(createAssignmentsList(items, createOptions(true)));
            teamSection.classList.remove('hidden');
          }


        } catch (e) {
          console.log('Could not load open assignments:', e.message);
        }
      }

      /**
       * Stub kept for backward compatibility ‚Äî Recent Activity is now rendered
       * inside loadOpenAssignments() using the same history API response,
       * avoiding a duplicate network request.
       */
      async function loadRecentActivity() {
        // No-op: renderRecentActivity() is called from loadOpenAssignments()
        // after the history fetch completes. This stub prevents errors if
        // any external code calls loadRecentActivity() directly.
      }

      /**
       * Render Recent Activity from already-fetched history data.
       * Called by loadOpenAssignments() after it fetches archer history,
       * avoiding a duplicate API call.
       *
       * Shows the last 4 completed/verified items for the selected archer.
       * Displays consistent round-type labels and status badges across all types.
       *
       * @param {Array} history - Full history array from /api/v1/archers/{id}/history
       * @param {string} archerId - UUID of the current archer (for building links)
       */
      function renderRecentActivity(history, archerId) {
        const container = document.getElementById('recent-activity');
        const list = document.getElementById('recent-activity-list');
        if (!container || !list) return;

        // Filter for COMP (completed, awaiting verification) or VER (coach-verified)
        const completed = history.filter(item => {
          const status = (item.card_status || '').toUpperCase();
          return status === 'COMP' || status === 'COMPLETED' || status === 'VER' || status === 'VERIFIED';
        });

        // Sort most-recent first, take last 4
        completed.sort((a, b) => new Date(b.event_date || 0) - new Date(a.event_date || 0));
        const recent = completed.slice(0, 4);

        if (recent.length === 0) {
          container.classList.add('hidden');
          return;
        }

        /**
         * Map a history item to a display object with consistent field names.
         * Uses the same labels as the assignment cards above.
         */
        const displayItems = recent.map(item => {
          const rawStatus = (item.card_status || '').toUpperCase();
          // Status badge: COMP = submitted for verification, VER = coach verified
          const isVerified = rawStatus === 'VER' || rawStatus === 'VERIFIED';
          const statusLabel = isVerified ? 'Verified' : 'COMP';
          const statusClass = isVerified
            ? 'bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300'
            : 'bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300';

          const dateStr = item.event_date
            ? new Date(item.event_date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
            : '';

          if (item.type === 'ranking') {
            // Ranking round ‚Äî consistent with assignment card labels
            const eventName = item.event_name || 'Ranking Round';
            let subtitle = [dateStr, item.round_type || 'R300'].filter(Boolean).join(' ‚Ä¢ ');
            if (item.division) subtitle += ` ‚Ä¢ ${item.division}`;
            return {
              typeIcon: 'fas fa-trophy',
              typeColor: 'text-teal-600 dark:text-teal-400',
              typeBg: 'bg-teal-50 dark:bg-teal-900/30',
              title: eventName,
              subtitle,
              score: item.final_score != null ? String(item.final_score) : '‚Äî',
              scoreLabel: 'pts',
              statusLabel,
              statusClass,
              link: `ranking_round_300.html?event=${item.event_id || 'null'}&round=${item.round_id}&archer=${archerId || ''}`
            };
          } else if (item.type === 'solo') {
            // Solo match ‚Äî consistent with assignment card: "vs [Opponent]"
            const eventName = item.event_name || 'Solo Match';
            const oppName = item.opponent_name || 'Opponent';
            const setsWon = item.sets_won ?? 0;
            const oppSets = item.opponent_sets_won ?? 0;
            const trophy = item.is_winner ? ' üèÜ' : '';
            return {
              typeIcon: 'fas fa-user-friends',
              typeColor: 'text-yellow-600 dark:text-yellow-400',
              typeBg: 'bg-yellow-50 dark:bg-yellow-900/30',
              title: eventName,
              subtitle: `${dateStr ? dateStr + ' ‚Ä¢ ' : ''}vs ${oppName}`,
              score: `${setsWon}‚Äì${oppSets}${trophy}`,
              scoreLabel: 'sets',
              statusLabel,
              statusClass,
              link: `solo_card.html?match=${item.match_id}`
            };
          } else if (item.type === 'team') {
            // Team match ‚Äî consistent with assignment card: "[My Team] vs [Opponent]"
            const eventName = item.event_name || 'Team Match';
            const myTeam = item.team_name || 'My Team';
            const oppTeam = item.opponent_team || 'Opponent';
            const setsWon = item.sets_won ?? 0;
            const oppSets = item.opponent_sets_won ?? 0;
            const trophy = item.is_winner ? ' üèÜ' : '';
            return {
              typeIcon: 'fas fa-users',
              typeColor: 'text-orange-600 dark:text-orange-400',
              typeBg: 'bg-orange-50 dark:bg-orange-900/30',
              title: eventName,
              subtitle: `${dateStr ? dateStr + ' ‚Ä¢ ' : ''}${myTeam} vs ${oppTeam}`,
              score: `${setsWon}‚Äì${oppSets}${trophy}`,
              scoreLabel: 'sets',
              statusLabel,
              statusClass,
              link: `team_card.html?match=${item.match_id}`
            };
          } else {
            // Unknown type ‚Äî generic fallback
            return {
              typeIcon: 'fas fa-circle',
              typeColor: 'text-gray-500',
              typeBg: 'bg-gray-50 dark:bg-gray-800',
              title: item.event_name || 'Activity',
              subtitle: dateStr,
              score: item.final_score != null ? String(item.final_score) : '‚Äî',
              scoreLabel: '',
              statusLabel,
              statusClass,
              link: '#'
            };
          }
        });

        list.innerHTML = displayItems.map(d => `
          <a href="${d.link}"
             class="flex items-center gap-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg px-3 py-3 min-h-[60px] hover:bg-gray-50 dark:hover:bg-gray-700 active:bg-gray-100 dark:active:bg-gray-600 transition-colors">
            <!-- Round-type icon -->
            <div class="flex-shrink-0 w-9 h-9 rounded-full ${d.typeBg} flex items-center justify-center">
              <i class="${d.typeIcon} text-sm ${d.typeColor}"></i>
            </div>
            <!-- Title + subtitle -->
            <div class="flex-1 min-w-0">
              <div class="text-sm font-semibold text-gray-900 dark:text-white truncate leading-tight">${d.title}</div>
              <div class="text-xs text-gray-500 dark:text-gray-400 truncate leading-tight mt-0.5">${d.subtitle}</div>
            </div>
            <!-- Score + status -->
            <div class="flex-shrink-0 flex flex-col items-end gap-1">
              <div class="text-base font-bold text-gray-900 dark:text-white whitespace-nowrap">${d.score}</div>
              <span class="text-[10px] font-semibold px-1.5 py-0.5 rounded ${d.statusClass} whitespace-nowrap">${d.statusLabel}</span>
            </div>
          </a>
        `).join('');

        container.classList.remove('hidden');
      }


      async function clearAppData() {
        const confirmed = confirm('Reset local app data? This clears cached archers, events, and scoring sessions stored on this device.');
        if (!confirmed) return;

        const exactKeys = [
          'archerList',
          'archerListMeta',
          'archerListPendingUpserts',
          'archerSelfExtId',
          'live_updates_config',
          'coach_api_key',
          'event_entry_code',
          'archery_master_list',
          'archery_tools_onboarding_complete',
          // Active in-progress sessions that drive "Resume Round" / reconnect flows
          // If we leave these behind, the app will try to auto-restore old rounds
          // immediately after a reset, which is what you are seeing.
          'current_bale_session'
        ];
        const keyPrefixes = [
          'rankingRound_',
          'rankingRound300_',
          'event:',
          'LiveUpdates:',
          // LiveUpdates round-scoped sessions (used for resume/reconnect)
          // Example key: "live_updates_session:<roundId>"
          'live_updates_session:',
          // Solo card sessions (daily local solo scorecard state)
          // Example key: "soloCard_session_2025-11-29"
          'soloCard_session_',
          'cachedRound:',
          'coachSession:',
          'manualBale:',
          'luq:'
        ];

        try {
          const keys = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (!key) continue;
            keys.push(key);
          }
          keys.forEach(key => {
            if (exactKeys.includes(key) || keyPrefixes.some(prefix => key.startsWith(prefix))) {
              localStorage.removeItem(key);
            }
          });
        } catch (err) {
          console.warn('Local storage clear failed:', err);
        }

        try { sessionStorage.clear(); } catch (err) { console.warn('Session storage clear failed:', err); }

        if (window.caches && typeof window.caches.keys === 'function') {
          try {
            const cacheNames = await window.caches.keys();
            await Promise.all(cacheNames.map(name => window.caches.delete(name)));
          } catch (err) {
            console.warn('Cache API clear failed:', err);
          }
        }

        // Unregister Service Worker so next load gets fresh app assets (JS/CSS)
        if ('serviceWorker' in navigator) {
          try {
            const regs = await navigator.serviceWorker.getRegistrations();
            await Promise.all(regs.map(r => r.unregister()));
          } catch (err) {
            console.warn('Service Worker unregister failed:', err);
          }
        }

        // Clear cookies - explicitly delete known cookies with multiple paths/domains
        const knownCookies = ['oas_archer_id', 'coach_auth'];
        const paths = ['/'];
        const domains = [window.location.hostname, '.' + window.location.hostname, ''];

        try {
          // First, explicitly clear known cookies with all path/domain combinations
          knownCookies.forEach(cookieName => {
            paths.forEach(path => {
              domains.forEach(domain => {
                if (domain) {
                  document.cookie = `${cookieName}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=${path};domain=${domain}`;
                } else {
                  document.cookie = `${cookieName}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=${path}`;
                }
              });
            });
          });

          // Then, clear all other cookies visible in document.cookie
          document.cookie.split(';').forEach(cookieStr => {
            const cookie = cookieStr.trim();
            if (!cookie) return;
            const eqPos = cookie.indexOf('=');
            const name = eqPos > -1 ? cookie.substring(0, eqPos) : cookie;
            if (!name) return;
            // Try multiple paths to ensure deletion
            paths.forEach(path => {
              document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=${path}`;
            });
          });
        } catch (err) {
          console.warn('Cookie clear failed:', err);
        }

        // Clear IndexedDB if it exists
        if (window.indexedDB && window.indexedDB.databases) {
          try {
            const databases = await window.indexedDB.databases();
            await Promise.all(databases.map(db => {
              return new Promise((resolve, reject) => {
                const deleteReq = window.indexedDB.deleteDatabase(db.name);
                deleteReq.onsuccess = () => resolve();
                deleteReq.onerror = () => reject(deleteReq.error);
                deleteReq.onblocked = () => resolve(); // Resolve anyway if blocked
              });
            }));
          } catch (err) {
            console.warn('IndexedDB clear failed:', err);
          }
        }

        alert('Local app data cleared. The page will reload now.');
        // Force hard reload to clear page cache (bypass cache)
        // Using href assignment with timestamp to force cache bypass
        window.location.href = window.location.pathname + '?nocache=' + Date.now();
      }

      // Initialize dark mode immediately (before DOMContentLoaded) to prevent flash
      initDarkMode();

      // Register Service Worker for PWA
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('sw.js', { scope: '/' })
            .then((registration) => {
              console.log('[PWA] Service Worker registered:', registration.scope);

              // Listen for messages from service worker (e.g., flush queues)
              navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'FLUSH_QUEUES') {
                  console.log('[PWA] Service worker requested queue flush');
                  // Flush all queues if LiveUpdates is available
                  if (window.LiveUpdates) {
                    try {
                      // Flush ranking round queue
                      if (window.LiveUpdates.flushQueue) {
                        window.LiveUpdates.flushQueue().catch(e =>
                          console.warn('[PWA] Ranking queue flush failed:', e)
                        );
                      }
                      // Note: Solo and team queues are flushed by their respective modules
                      // when they detect online status or receive flush requests
                    } catch (e) {
                      console.warn('[PWA] Queue flush error:', e);
                    }
                  }
                }
              });

              // Notify service worker when online status changes
              window.addEventListener('online', () => {
                if (registration.active) {
                  registration.active.postMessage({
                    type: 'ONLINE_STATUS',
                    online: true
                  });
                }
              });

              window.addEventListener('offline', () => {
                if (registration.active) {
                  registration.active.postMessage({
                    type: 'ONLINE_STATUS',
                    online: false
                  });
                }
              });

              // Check for updates periodically
              setInterval(() => {
                registration.update();
              }, 60 * 60 * 1000); // Check every hour

              // Handle updates
              registration.addEventListener('updatefound', () => {
                const newWorker = registration.installing;
                if (newWorker) {
                  newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                      // New service worker available
                      console.log('[PWA] New service worker available. Reload to update.');
                      // Optionally show a notification to the user
                    }
                  });
                }
              });
            })
            .catch((error) => {
              console.warn('[PWA] Service Worker registration failed:', error);
            });
        });
      }

      // Initialize the app
      document.addEventListener('DOMContentLoaded', function () {
        const clearBtn = document.getElementById('clear-cache-btn');
        if (clearBtn) {
          clearBtn.addEventListener('click', () => {
            clearAppData();
          });
        }

        // Load archer list first (needed for identity section)
        loadArcherList().then(() => {
          // Render identity section (inline archer picker or profile)
          renderIdentitySection();
          loadOpenAssignments();
          loadRecentActivity();
        });

        // Intercept Ranking Round link to check for local in-progress cards
        const rankingRoundLink = document.getElementById('ranking-round-link');
        if (rankingRoundLink) {
          rankingRoundLink.addEventListener('click', (e) => {
            // Check for local in-progress session
            const sessionData = localStorage.getItem('current_bale_session');
            if (sessionData) {
              try {
                const session = JSON.parse(sessionData);
                // Check if session is recent (within 24 hours)
                const sessionAge = Date.now() - new Date(session.lastSaved || 0).getTime();
                const maxAge = 24 * 60 * 60 * 1000; // 24 hours

                if (sessionAge <= maxAge && session.roundId && session.baleNumber) {
                  // Session exists and is recent - let ranking_round_300.html handle the resume dialog
                  // Just navigate normally, the resume dialog will show automatically
                  console.log('[index] Local in-progress session found, navigating to ranking round (resume dialog will show)');
                  return; // Allow normal navigation
                } else {
                  // Session too old, clear it
                  localStorage.removeItem('current_bale_session');
                  console.log('[index] Local session too old, cleared');
                }
              } catch (err) {
                console.warn('[index] Error checking local session:', err);
                // Continue with normal navigation
              }
            }
            // No local session or invalid - allow normal navigation
          });
        }

        // Dark mode toggle functionality (only on home screen)
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        if (darkModeToggle) {
          darkModeToggle.addEventListener('click', () => {
            toggleDarkMode();
          });
        }
        // Expose voidMatch globally for inline onclick handlers
        window.voidMatch = async (matchId, type) => {
          if (!confirm('Are you sure you want to void this match? This cannot be undone.')) return;

          try {
            const res = await fetch(`api/v1/solo-matches/${matchId}/void`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            });

            if (res.ok) {
              alert('Match voided successfully.');
              // Reload assignments
              loadOpenAssignments();
            } else {
              const data = await res.json();
              alert('Failed to void match: ' + (data.error || 'Unknown error'));
            }
          } catch (e) {
            console.error('Void error:', e);
            alert('Error voiding match');
          }
        };

      });
    </script>
</body>

</html>