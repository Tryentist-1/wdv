<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Olympic Archery Scorer</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/addons/p5.dom.min.js"></script>

    <style>
        /* Basic CSS for layout and appearance */
        html, body {
            margin: 0;
            padding: 0;
            /* Prevent annoying scrollbars if canvas fits viewport */
            overflow: hidden;
            font-family: sans-serif;
            /* Match canvas background for smoother look */
            background-color: #f0f0f0;
            height: 100%; /* Ensure body takes full height */
        }
        canvas {
            /* Prevent extra space below canvas */
            display: block;
        }
        /* Basic button styling for better visibility/touch */
        button {
            padding: 10px 15px;
            font-size: 1em; /* Relative font size */
            cursor: pointer;
            /* Add some visual separation */
            margin-top: 5px;
        }
        /* Simple header style */
        h3 {
            text-align: center;
            margin: 5px 0 0 0; /* Reduced margin */
            font-weight: normal;
            color: #555;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <h3>Interactive Olympic Archery Scorer (p5.js). Code prompted by Tryentist and generated by Google Gemini.</h3>
    <script>
        // --- Configuration ---
        let arrowsPerEnd = 3;
        let numEnds = 6;
        let targetX, targetY;
        let targetRadius;
        const ringColors = [
          [255, 255, 255], // 1, 2 (White)
          [255, 255, 255],
          [0, 0, 0],       // 3, 4 (Black)
          [0, 0, 0],
          [100, 150, 255], // 5, 6 (Blue)
          [100, 150, 255],
          [255, 80, 80],   // 7, 8 (Red)
          [255, 80, 80],
          [255, 255, 100], // 9, 10, X (Yellow)
          [255, 255, 100],
        ];
        const ringScores = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let ringRadii = []; // Radii for each scoring ring boundary (10 down to 1)
        let xRingRadius;
        const xRingInputFactor = 0.65; // Keep X click area slightly larger

        // --- Match State ---
        let matchData = [];
        let currentEnd = 1;
        let currentArrowInEnd = 1;
        let matchOver = false;

        // --- End of Match Stats & Analysis ---
        let totalScore = 0;
        let numXs = 0;
        let numTens = 0; // Non-X 10s
        let avgX = 0;
        let avgY = 0;
        let totalArrowsShot = 0;
        let biasDescription = "";

        // --- UI Elements ---
        let resetButton;
        let saveButton;

        // =================== SETUP ===================
        function setup() {
          let canvasHeight = windowHeight * 0.85; // Keep space for buttons
          createCanvas(windowWidth, canvasHeight);
          targetX = width * 0.35;
          targetY = height / 2;
          targetRadius = min(height * 0.45, width * 0.3);

          calculateRadii(); // Calculate initial radii

          // --- Create Buttons ---
          resetButton = createButton('Reset / Configure');
          resetButton.position(width * 0.4 - resetButton.width / 2, height + 10); // Position relative left
          resetButton.mousePressed(configureAndResetMatch); // Link to config/reset function

          saveButton = createButton('Save Results');
          saveButton.position(width * 0.6 - saveButton.width / 2, height + 10); // Position relative right
          saveButton.mousePressed(saveScorecard); // Link to save function
          saveButton.hide(); // Hide initially, show when match is over

          textAlign(LEFT, TOP);
          textSize(16);
          noStroke();

          // Initialize data structure without prompting immediately
          initializeMatchData(false); // false = don't prompt yet
        }

        // =================== CONFIG & RESET ===================
        function configureAndResetMatch() {
            // Prompt for configuration
            let inputArrows = prompt(`Enter number of arrows per end:`, arrowsPerEnd);
            let inputEnds = prompt(`Enter number of ends:`, numEnds);

            // Validate and update configuration
            let newArrowsPerEnd = parseInt(inputArrows);
            if (!isNaN(newArrowsPerEnd) && newArrowsPerEnd > 0) {
                arrowsPerEnd = newArrowsPerEnd;
            } // Keep existing value if invalid

            let newNumEnds = parseInt(inputEnds);
            if (!isNaN(newNumEnds) && newNumEnds > 0) {
                numEnds = newNumEnds;
            } // Keep existing value if invalid

            // Now reset the match state with potentially new config
            initializeMatchData(true); // true = log the reset action
        }

        function initializeMatchData(logReset = true) {
          matchData = [];
          // Ensure matchData is sized correctly based on potentially new numEnds
          for (let i = 0; i < numEnds; i++) {
            matchData.push([]);
          }
          currentEnd = 1;
          currentArrowInEnd = 1;
          matchOver = false;

          // Reset stats
          totalScore = 0;
          numXs = 0;
          numTens = 0;
          avgX = 0;
          avgY = 0;
          totalArrowsShot = 0;
          biasDescription = "";

          if(saveButton) saveButton.hide(); // Hide save button on reset

          if (logReset) {
            console.log(`Match Reset: ${numEnds} ends, ${arrowsPerEnd} arrows per end.`);
          }

          // Force redraw needed elements after reset
          if (typeof draw === 'function' && typeof width !== 'undefined' && width > 0) {
              loop(); // Ensure loop is running
              redraw();
          }
        }

        // =================== CORE DRAWING & LOGIC ===================

        // ***** CORRECTED calculateRadii *****
        function calculateRadii() {
          ringRadii = []; // Clear previous radii
          let ringWidth = targetRadius / 10; // Width of one score zone

          for (let i = 0; i < 10; i++) {
            // Calculate the radius for the outer edge of score zone (10-i)
            // Score 10 (i=0) -> Radius = 1 * ringWidth
            // Score 9  (i=1) -> Radius = 2 * ringWidth
            // ...
            // Score 1  (i=9) -> Radius = 10 * ringWidth = targetRadius
            let scoreZoneRadius = (i + 1) * ringWidth;
            ringRadii.push(scoreZoneRadius);
          }
          // Now ringRadii array is ordered correctly:
          // ringRadii[0] = radius of 10-ring boundary
          // ringRadii[1] = radius of 9-ring boundary
          // ...
          // ringRadii[9] = radius of 1-ring boundary (the full targetRadius)

          // Calculate X-Ring radius based on the 10-ring radius (ringRadii[0])
          // X-Ring radius is half the 10-ring radius. Apply input factor.
          if (ringRadii.length > 0) { // Ensure ringRadii[0] exists
             xRingRadius = (ringRadii[0] / 2) * xRingInputFactor;
          } else {
             xRingRadius = 0; // Safety fallback
          }


          // --- For Debugging (Optional: Uncomment to check values in console) ---
           console.log("Recalculated Radii (10 down to 1):", ringRadii.map(r=>r?r.toFixed(1):'N/A'));
           console.log("Recalculated X Radius:", xRingRadius.toFixed(1));
           console.log("Target Radius:", targetRadius.toFixed(1));
          // --- End Debugging ---
        }
        // ***** END CORRECTED calculateRadii *****


        function draw() {
          background(240);

          drawTarget();
          drawArrowMarkers();
          displayScoreboard();
          displayCurrentStatus(); // Shows current arrow OR end results

          // Draw average group position if match is over
          if (matchOver && totalArrowsShot > 0) {
            drawAveragePosition();
          }
        }

        // ***** CORRECTED getScore (works with new calculateRadii) *****
        function getScore(x, y) {
          let d = dist(x, y, targetX, targetY);
          // --- For Debugging (Optional: Uncomment to check distances) ---
          // console.log(`getScore - Dist: ${d.toFixed(1)}`);
          // --- End Debugging ---

          // Check X first
          if (d <= xRingRadius) {
             // console.log("Score -> X"); // Debugging
            return 'X';
          }

          // Check rings 10 down to 1 using the corrected ringRadii array
          // Make sure ringRadii is populated before checking
          if (!ringRadii || ringRadii.length !== 10) {
              console.error("Ring radii not calculated correctly.");
              return 0; // Prevent errors if radii aren't ready
          }

          for (let i = 0; i < 10; i++) {
             // ringRadii[i] is the radius boundary for score (10-i)
             // i=0: check d <= ringRadii[0] (10-ring), score = 10-0 = 10
             // i=1: check d <= ringRadii[1] (9-ring), score = 10-1 = 9
             // ...
             // i=9: check d <= ringRadii[9] (1-ring), score = 10-9 = 1
            if (d <= ringRadii[i]) {
                let score = 10 - i;
               // console.log(`Score -> ${score}`); // Debugging
               return score;
            }
          }

          // console.log("Score -> 0 (Miss)"); // Debugging
          return 0; // Missed the target scoring area (outside ring 1)
        }
         // ***** END CORRECTED getScore *****


        function mousePressed() {
            // Ignore clicks outside canvas (likely UI interaction)
          if (mouseY < 0 || mouseY > height || mouseX < 0 || mouseX > width) {
             return;
          }

          if (matchOver) return; // Don't score if match is finished

          let d = dist(mouseX, mouseY, targetX, targetY);
          if (d <= targetRadius) {
            let score = getScore(mouseX, mouseY);
            if (score !== 0) {
              let arrowData = {
                score: score,
                value: (score === 'X' ? 10 : score),
                x: mouseX,
                y: mouseY,
                end: currentEnd,
                arrowInEnd: currentArrowInEnd
              };

              if(!matchData[currentEnd - 1]) matchData[currentEnd - 1] = [];
              matchData[currentEnd - 1].push(arrowData);
              // console.log(`End ${currentEnd}, Arrow ${currentArrowInEnd}: ${score} at (${mouseX.toFixed(0)}, ${mouseY.toFixed(0)})`); // Less verbose logging

              // --- Advance arrow/end state ---
              currentArrowInEnd++;
              if (currentArrowInEnd > arrowsPerEnd) {
                currentEnd++;
                currentArrowInEnd = 1;

                // --- Check if Match is Over ---
                if (currentEnd > numEnds) {
                  matchOver = true;
                  console.log("Match Over. Calculating final stats...");
                  calculateFinalStats(); // Calculate stats *once* when match ends
                  if(saveButton) saveButton.show(); // Show save button
                  noLoop(); // Stop draw loop once match is over to save resources
                  redraw(); // Draw one final frame with results
                }
              }
            }
          }
        }

        // =================== END OF MATCH CALCULATIONS ===================
        function calculateFinalStats() {
            totalScore = 0;
            numXs = 0;
            numTens = 0;
            let sumX = 0;
            let sumY = 0;
            totalArrowsShot = 0;

            // Check if matchData exists and is an array
             if (!matchData || !Array.isArray(matchData)) {
                 console.error("Match data is missing or invalid for final stats.");
                 biasDescription = "Error calculating stats.";
                 return;
             }


            for (let endArr of matchData) {
                // Check if endArr exists and is an array
                if (!endArr || !Array.isArray(endArr)) continue;

                for (let arrow of endArr) {
                    // Check if arrow object and properties exist
                    if (!arrow || typeof arrow.value === 'undefined' || typeof arrow.score === 'undefined' || typeof arrow.x === 'undefined' || typeof arrow.y === 'undefined') continue;

                    totalScore += arrow.value;
                    if (arrow.score === 'X') numXs++;
                    // Ensure we only count literal 10s, not 'X' which also has value 10
                    if (arrow.score === 10) numTens++;
                    sumX += arrow.x;
                    sumY += arrow.y;
                    totalArrowsShot++;
                }
            }

            // Calculate Average Position
            if (totalArrowsShot > 0) {
                avgX = sumX / totalArrowsShot;
                avgY = sumY / totalArrowsShot;
                analyzeBias(avgX, avgY); // Analyze group center bias
            } else {
                avgX = targetX; // Default to center if no arrows shot
                avgY = targetY;
                biasDescription = "No arrows shot.";
            }

            console.log(`Final Score: ${totalScore}, Xs: ${numXs}, 10s: ${numTens}`);
            console.log(`Avg Pos: (${avgX.toFixed(1)}, ${avgY.toFixed(1)}), Bias: ${biasDescription}`);
        }

        function analyzeBias(ax, ay) {
            let deltaX = ax - targetX;
            let deltaY = ay - targetY; // Smaller Y is higher
            let threshold = targetRadius / 10; // Bias if > 1 ring width off center
            let biasParts = [];

            // Vertical Bias
            if (deltaY < -threshold) biasParts.push("High");
            else if (deltaY > threshold) biasParts.push("Low");

            // Horizontal Bias
            if (deltaX < -threshold) biasParts.push("Left");
            else if (deltaX > threshold) biasParts.push("Right");

            // Combine description
            if (biasParts.length === 0) {
                biasDescription = "Group centered well.";
            } else {
                biasDescription = "Group centered: " + biasParts.join(" and ") + ".";
            }
        }


        // =================== DRAWING HELPERS ===================
        function drawTarget() {
          push();
          translate(targetX, targetY);
          noStroke();
          // Ensure ringRadii is valid before drawing rings based on it
          if (!ringRadii || ringRadii.length !== 10) return;
          // Rings (outside in)
          fill(ringColors[0]); ellipse(0, 0, targetRadius * 2); // Ring 1/2 White Base
          fill(ringColors[2]); ellipse(0, 0, ringRadii[7] * 2); // Black (Starts outside Ring 4 -> radius of Ring 3 = ringRadii[7])? No.
          // Let's redraw based on score zones for clarity
          // Ring 1/2 White base is already drawn (targetRadius)
          // Ring 3/4 Black (outer radius is ringRadii[7] / score 3)
          fill(ringColors[2]); ellipse(0, 0, ringRadii[7] * 2);
           // Ring 5/6 Blue (outer radius is ringRadii[5] / score 5)
          fill(ringColors[4]); ellipse(0, 0, ringRadii[5] * 2);
           // Ring 7/8 Red (outer radius is ringRadii[3] / score 7)
          fill(ringColors[6]); ellipse(0, 0, ringRadii[3] * 2);
          // Ring 9/10/X Yellow (outer radius is ringRadii[1] / score 9)
          fill(ringColors[8]); ellipse(0, 0, ringRadii[1] * 2);


          // Lines
          stroke(0); strokeWeight(1); noFill();
          // Draw circles for score zones 10 down to 2 (boundary lines)
          for (let i = 0; i < 9; i++) { // ringRadii[0] to ringRadii[8]
            ellipse(0, 0, ringRadii[i] * 2);
          }
          // Draw X-Ring line using calculated xRingRadius
          ellipse(0, 0, xRingRadius * 2);
          pop();
        }


        function drawArrowMarkers() {
          push();
          if (!matchData || !Array.isArray(matchData)) return;
          for (let endArr of matchData) {
            if (!endArr || !Array.isArray(endArr)) continue;
            for (let arrow of endArr) {
               if (!arrow || typeof arrow.x === 'undefined' || typeof arrow.y === 'undefined') continue;
              fill(0, 0, 0, 200); noStroke();
              ellipse(arrow.x, arrow.y, 8, 8); // Arrow marker size
            }
          }
          pop();
        }

        function drawAveragePosition() {
            push();
            fill(255, 0, 0, 180); // Red with some transparency
            noStroke();
            ellipse(avgX, avgY, 15, 15); // Size of the average marker
            pop();
        }

        function displayScoreboard() {
          push();
          let scoreX = min(width - 180, targetX + targetRadius + 20);
          let scoreY = 50;
          let lineHeight = 20;
          fill(0);
          textSize(14);
          textAlign(LEFT, TOP);
          textFont('monospace');
          textStyle(BOLD);
          text("End Scores", scoreX, scoreY - lineHeight * 1.5);
          textStyle(NORMAL);

          if (!matchData || !Array.isArray(matchData)) return;

          for (let i = 0; i < numEnds; i++) {
             // Ensure the array has space for this end, even if empty
             if (!matchData[i]) matchData[i] = [];
             let endArrows = matchData[i];
             let endTotal = 0;

             for(let arrow of endArrows) {
                 if (arrow && typeof arrow.value !== 'undefined') endTotal += arrow.value;
              }

             // Calculate running total up to the *end* of this end (i) accurately
             let displayRunningTotal = 0;
             for (let k=0; k<=i; k++){
                 if(matchData[k] && Array.isArray(matchData[k])){
                     for(let arrow of matchData[k]){
                          if (arrow && typeof arrow.value !== 'undefined') displayRunningTotal += arrow.value;
                     }
                 }
             }

             // Display logic
             if (endArrows.length === 0 && (i + 1) > currentEnd && !matchOver) {
                 continue;
             }

             let endScoreTexts = [];
             for (let j = 0; j < arrowsPerEnd; j++) {
                if (j < endArrows.length && endArrows[j] && typeof endArrows[j].score !== 'undefined') {
                   endScoreTexts.push(String(endArrows[j].score).padStart(2));
                } else {
                   endScoreTexts.push("  ");
                }
             }
             let scoreString = endScoreTexts.join(', ');
             let displayLine = `E${String(i + 1).padStart(2)}: ${scoreString} | ${String(endTotal).padStart(3)} | ${String(displayRunningTotal).padStart(4)}`;
             text(displayLine, scoreX, scoreY + i * lineHeight);
          }
          pop();
        }


        function displayCurrentStatus() {
          push();
          fill(0);
          textAlign(CENTER, TOP);
          textSize(16);
          let statusY = 15;

          if (matchOver) {
            let scoreSummary = `Match Over! Score: ${totalScore} (${numXs} X's, ${numTens} 10's)`;
            text(scoreSummary, width / 2, statusY);
            textSize(14);
            text(biasDescription, width / 2, statusY + 20);
          } else {
            let statusText = `Shooting End: ${currentEnd}/${numEnds}, Arrow: ${currentArrowInEnd}/${arrowsPerEnd}`;
            text(statusText, width / 2, statusY);
          }
          pop();
        }

        // =================== UTILITIES ===================

        function saveScorecard() {
            console.log("Saving scorecard...");
            let d = new Date();
            let timestamp = `${d.getFullYear()}${nf(d.getMonth() + 1, 2)}${nf(d.getDate(), 2)}_${nf(d.getHours(), 2)}${nf(d.getMinutes(), 2)}${nf(d.getSeconds(), 2)}`;
            let filename = `ArcheryScore_${timestamp}.png`;

            if (!isLooping()) {
                redraw(); // Ensure final state is drawn before saving
            }
            saveCanvas(filename);
        }

        function windowResized() {
          let canvasHeight = windowHeight * 0.85;
          resizeCanvas(windowWidth, canvasHeight);
          targetX = width * 0.35;
          targetY = height / 2;
          targetRadius = min(height * 0.45, width * 0.3);
          calculateRadii(); // Recalculate ring sizes

          // Reposition buttons
          if (resetButton) resetButton.position(width * 0.4 - resetButton.width / 2, height + 10);
          if (saveButton) saveButton.position(width * 0.6 - saveButton.width / 2, height + 10);

          if (!isLooping() || matchOver) {
             redraw(); // Redraw immediately
          }
        }

    </script>

</body>
</html>