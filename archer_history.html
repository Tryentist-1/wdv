<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Archer History</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link rel="stylesheet" href="css/tailwind-compiled.css">
  <link rel="stylesheet" href="css/unified-scorecard-list.css">
  <script src="js/common.js"></script>
  <script>
    // Initialize dark mode immediately (before DOMContentLoaded) to prevent flash
    // Dark mode preference is set from the home screen (index.html)
    if (typeof initDarkMode === 'function') {
      initDarkMode();
    } else {
      // Fallback if common.js not loaded yet
      (function() {
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
      })();
    }
  </script>
  <script src="js/scorecard_view.js"></script>
  <script src="js/solo_match_view.js"></script>
  <script src="js/unified_scorecard_list.js"></script>
</head>
<body class="bg-gray-50 dark:bg-gray-900 min-h-screen transition-colors duration-200">
  <div class="max-w-6xl mx-auto px-4 py-6 pb-[calc(48px+env(safe-area-inset-bottom))]">
    <!-- Header -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-6 transition-colors duration-200 flex justify-between items-center">
      <h1 id="page-title" class="text-3xl font-bold text-gray-800 dark:text-white">Archer History</h1>
    </div>

    <!-- Archer Info -->
    <div id="archer-info" class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-6 transition-colors duration-200 hidden">
      <h2 id="archer-name" class="text-2xl font-bold text-gray-800 dark:text-white mb-3">-</h2>
      <div class="flex gap-6 flex-wrap text-gray-600 dark:text-gray-400 text-sm">
        <span>üè´ School: <strong id="archer-school" class="text-gray-800 dark:text-white">-</strong></span>
        <span>üìä Level: <strong id="archer-level" class="text-gray-800 dark:text-white">-</strong></span>
        <span>üë§ Gender: <strong id="archer-gender" class="text-gray-800 dark:text-white">-</strong></span>
        <span>üéØ Total Rounds: <strong id="total-rounds" class="text-gray-800 dark:text-white">0</strong></span>
        <span>üéØ Solo Record: <strong id="solo-record" class="text-gray-800 dark:text-white">-</strong></span>
      </div>
    </div>

    <!-- Loading/Error States -->
    <div id="loading" class="text-center py-12 text-gray-600 dark:text-gray-400">Loading history...</div>
    <div id="error" class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-400 px-4 py-3 rounded-lg my-6 hidden"></div>

    <!-- History List -->
    <div id="history-container" class="mb-6 hidden">
      <div class="scorecard-list-container">
        <div class="scorecard-list-header grid gap-1.5 px-2.5 py-2 bg-gray-100 dark:bg-gray-700 border-b border-gray-200 dark:border-gray-600 text-[11px] font-semibold text-gray-700 dark:text-gray-300 uppercase tracking-wide items-center sticky top-0 z-10 min-w-0 sm:gap-2 sm:px-3 sm:py-2.5 sm:text-xs"
             style="grid-template-columns: minmax(0, 2fr) minmax(55px, 1fr) minmax(65px, 1fr) minmax(55px, 1fr) minmax(35px, 0.5fr) minmax(35px, 0.5fr);"
             data-columns="6">
          <div class="text-center">Event</div>
          <div class="text-center">Status</div>
          <div class="text-center">Total</div>
          <div class="text-center">Avg</div>
          <div class="text-center">Xs</div>
          <div class="text-center">10s</div>
        </div>
        <div id="history-body">
          <!-- Populated dynamically with unified scorecard list items -->
        </div>
      </div>
    </div>

    <div id="no-history" class="text-center py-12 text-gray-500 dark:text-gray-400 hidden">
      <p class="text-lg mb-2">No scoring history found.</p>
      <p>Start scoring to build your history!</p>
    </div>
  </div>

  <footer class="fixed bottom-0 left-0 right-0 h-[48px] bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 shadow-lg transition-colors duration-200 z-10 safe-area-bottom">
    <div class="max-w-6xl mx-auto flex items-center h-full px-4 gap-2">
      <a href="index.html" class="min-w-[48px] h-[48px] text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white active:bg-gray-100 dark:active:bg-gray-700 rounded-lg transition-colors flex items-center justify-center" aria-label="Home">
        <i class="fas fa-home text-2xl"></i>
      </a>
      <div class="flex-1"></div>
      <a href="archer_list.html" class="px-3 h-[44px] bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded font-semibold hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors flex items-center justify-center"><i class="fas fa-arrow-left mr-1"></i> Back to Archer List</a>
    </div>
  </footer>

  <script>
    // Use local API when running on localhost, otherwise use production
    const API_BASE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      ? `${window.location.protocol}//${window.location.hostname}:${window.location.port || 8001}/api/index.php/v1`
      : 'https://tryentist.com/wdv/api/v1';
    const urlParams = new URLSearchParams(window.location.search);
    const archerId = urlParams.get('archer') || urlParams.get('id') || urlParams.get('extId');
    
    // Store archer data globally so it can be accessed when viewing scorecards
    let currentArcherData = null;
    let historyData = []; // Store history for win/loss calculation

    /**
     * Calculate win/loss ratio from history for solo matches.
     * Handles both boolean (true/false) and numeric (1/0) values from PHP JSON encoding.
     * 
     * @param {Array<Object>} history - Array of history items from API
     * @param {string} history[].type - Type of history item ('solo', 'ranking', 'team')
     * @param {boolean|number|null} history[].is_winner - Winner status (true/1 = win, false/0 = loss, null = incomplete)
     * @returns {Object} Win/loss statistics
     * @returns {number} returns.wins - Number of wins
     * @returns {number} returns.losses - Number of losses
     * @returns {number} returns.total - Total solo matches
     * @returns {string} returns.ratio - Formatted ratio string (e.g., "5-3")
     */
    function calculateWinLossRatio(history) {
      const soloMatches = history.filter(item => item.type === 'solo');
      // Handle both boolean true/false and numeric 1/0 from PHP JSON encoding
      const wins = soloMatches.filter(m => m.is_winner === true || m.is_winner === 1).length;
      const losses = soloMatches.filter(m => m.is_winner === false || m.is_winner === 0).length;
      const total = soloMatches.length;
      
      return {
        wins,
        losses,
        total,
        ratio: `${wins}-${losses}`
      };
    }

    async function loadHistory() {
      if (!archerId) {
        showError('No archer ID provided. Please use ?archer={id} or ?extId={localId} in the URL.');
        return;
      }

      try {
        // Try with the provided ID first (could be UUID or external ID)
        let res = await fetch(`${API_BASE}/archers/${encodeURIComponent(archerId)}/history`);
        
        // If 404 and looks like external ID (contains hyphens but not UUID format), try searching by external ID
        if (!res.ok && res.status === 404 && archerId.includes('-') && !archerId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)) {
          console.log('First attempt failed, trying to find archer by external ID...');
          // Get all archers and find by external ID
          const archersRes = await fetch(`${API_BASE}/archers`);
          if (archersRes.ok) {
            const archersData = await archersRes.json();
            const archer = (archersData.archers || []).find(a => 
              (a.extId || '').toLowerCase() === archerId.toLowerCase() ||
              `${a.first_name}-${a.last_name}`.toLowerCase().replace(/\s+/g, '-') === archerId.toLowerCase()
            );
            if (archer && archer.id) {
              console.log('Found archer by external ID, fetching history with UUID:', archer.id);
              res = await fetch(`${API_BASE}/archers/${encodeURIComponent(archer.id)}/history`);
            }
          }
        }
        
        if (!res.ok) {
          if (res.status === 404) {
            showError('Archer not found. They may not have scored any rounds yet.');
          } else {
            throw new Error(`HTTP ${res.status}`);
          }
          return;
        }
        
        const data = await res.json();
        console.log('Archer history:', data);
        
        // Store archer data globally for scorecard viewing
        currentArcherData = data.archer;

        // Update archer info
        document.getElementById('archer-name').textContent = data.archer.fullName;
        document.getElementById('archer-school').textContent = data.archer.school || 'N/A';
        document.getElementById('archer-level').textContent = data.archer.level || 'N/A';
        document.getElementById('archer-gender').textContent = data.archer.gender === 'M' ? 'Male' : data.archer.gender === 'F' ? 'Female' : 'N/A';
        document.getElementById('total-rounds').textContent = data.totalRounds;
        
        // Store history for win/loss calculation
        historyData = data.history || [];
        
        // Calculate and display win/loss ratio
        const { wins, losses, ratio } = calculateWinLossRatio(historyData);
        document.getElementById('solo-record').textContent = ratio || '0-0';
        
        document.getElementById('archer-info').classList.remove('hidden');

        // Render history
        if (data.history.length === 0) {
          document.getElementById('no-history').classList.remove('hidden');
        } else {
          renderHistory(data.history);
          document.getElementById('history-container').classList.remove('hidden');
        }

        document.getElementById('loading').classList.add('hidden');
      } catch (err) {
        console.error('Error loading history:', err);
        showError('Failed to load archer history: ' + err.message);
      }
    }

    function renderHistory(history) {
      const container = document.getElementById('history-body');
      container.innerHTML = '';

      if (history.length === 0) {
        container.innerHTML = '<div class="text-center py-12 text-gray-500 dark:text-gray-400">No scoring history found for this archer.</div>';
        return;
      }

      const divisionNames = {
        'BVAR': 'Boys Varsity',
        'GVAR': 'Girls Varsity', 
        'BJV': 'Boys JV',
        'GJV': 'Girls JV'
      };

      history.forEach(item => {
        const row = document.createElement('div');
        row.className = 'scorecard-list-item grid gap-1.5 items-center bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-600 px-2.5 py-2 min-h-[2.75rem] min-w-0 transition-all duration-200 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 sm:gap-2 sm:px-3 sm:py-2.5 sm:min-h-[3rem]';
        row.style.gridTemplateColumns = 'minmax(0, 2fr) minmax(55px, 1fr) minmax(65px, 1fr) minmax(55px, 1fr) minmax(35px, 0.5fr) minmax(35px, 0.5fr)';
        row.setAttribute('data-columns', '6');
        
        // Status text - prioritize card_status from database
        let statusText = '';
        const cardStatus = (item.card_status || '').toUpperCase();
        
        if (cardStatus === 'VER' || cardStatus === 'VERIFIED') {
          statusText = 'VER';
        } else if (cardStatus === 'VOID') {
          statusText = 'VOID';
        } else if (cardStatus === 'COMP' || cardStatus === 'COMPLETED') {
          statusText = 'COMP';
        } else if (item.type === 'ranking' && (item.ends_completed >= 10 || item.final_score > 0)) {
          statusText = 'COMP';
        } else {
          statusText = 'PEND';
        }
        
        // Format date
        const eventDate = item.event_date ? new Date(item.event_date).toLocaleDateString('en-US', { 
          month: 'short', day: 'numeric', year: '2-digit' 
        }) : 'N/A';
        
        let eventName, subtitle, totalScore, avgScore, xs, tens;
        
        if (item.type === 'ranking') {
          // Ranking round display
          const roundTypeDisplay = item.round_type === 'PRACTICE' ? 'Practice' : (item.round_type || 'R300');
          eventName = item.event_name || (item.round_type === 'PRACTICE' ? 'Practice Round' : 'Unknown Event');
          const baleInfo = item.bale_number ? ` ‚Ä¢ Bale ${item.bale_number}` : '';
          subtitle = `${eventDate} ‚Ä¢ ${roundTypeDisplay} ‚Ä¢ ${divisionNames[item.division] || item.division || 'Open'}${baleInfo}`;
          totalScore = item.final_score || 0;
          avgScore = item.final_score && item.ends_completed ? 
            (item.final_score / (item.ends_completed * 3)).toFixed(1) : '0.0';
          xs = item.total_xs || 0;
          tens = item.total_tens || 0;
        } else if (item.type === 'solo') {
          // Solo match display
          eventName = item.event_name || 'Solo Match';
          const winIndicator = item.is_winner ? ' üèÜ' : '';
          subtitle = `${eventDate} ‚Ä¢ Solo Match vs ${item.opponent_name}${winIndicator}`;
          totalScore = `${item.sets_won}-${item.opponent_sets_won}`;
          avgScore = item.final_score || 0; // Show total score in avg column
          xs = '-';
          tens = '-';
        } else if (item.type === 'team') {
          // Team match display
          eventName = item.event_name || 'Team Match';
          const winIndicator = item.is_winner ? ' üèÜ' : '';
          subtitle = `${eventDate} ‚Ä¢ Team: ${item.team_name} vs ${item.opponent_team}${winIndicator}`;
          totalScore = `${item.sets_won}-${item.opponent_sets_won}`;
          avgScore = '-';
          xs = '-';
          tens = '-';
        } else {
          // Fallback for unknown types
          eventName = item.event_name || 'Unknown';
          subtitle = eventDate;
          totalScore = item.final_score || 0;
          avgScore = '0.0';
          xs = item.total_xs || 0;
          tens = item.total_tens || 0;
        }
        
        row.innerHTML = `
          <div class="flex flex-col gap-0.5 min-w-0 overflow-hidden">
            <div class="text-[13px] font-semibold text-gray-900 dark:text-white overflow-hidden text-ellipsis whitespace-nowrap leading-tight sm:text-sm">${eventName}</div>
            <div class="text-[11px] text-gray-600 dark:text-gray-400 overflow-hidden text-ellipsis whitespace-nowrap leading-tight sm:text-xs">${subtitle}</div>
          </div>
          <div class="text-[13px] font-semibold text-gray-900 dark:text-white text-center flex items-center justify-center min-w-0 whitespace-nowrap sm:text-sm">${statusText}</div>
          <div class="text-[15px] font-bold text-blue-600 dark:text-blue-400 text-center flex items-center justify-center min-w-0 whitespace-nowrap sm:text-base">${totalScore}</div>
          <div class="text-[13px] font-semibold text-gray-900 dark:text-white text-center flex items-center justify-center min-w-0 whitespace-nowrap sm:text-sm">${avgScore}</div>
          <div class="text-[13px] font-semibold text-gray-900 dark:text-white text-center flex items-center justify-center min-w-0 whitespace-nowrap sm:text-sm">${xs}</div>
          <div class="text-[13px] font-semibold text-gray-900 dark:text-white text-center flex items-center justify-center min-w-0 whitespace-nowrap sm:text-sm">${tens}</div>
        `;

        // Make the whole item clickable except for action buttons
        row.onclick = (e) => {
          if (e.target.closest('.scorecard-actions')) return;
          if (item.type === 'ranking') {
            showRoundScorecard(item);
          } else if (item.type === 'solo') {
            showSoloMatchScorecard(item);
          } else if (item.type === 'team') {
            // TODO: Show team match scorecard
            console.log('Team match clicked:', item);
          }
        };

        container.appendChild(row);
      });
    }

    function showError(message) {
      document.getElementById('loading').classList.add('hidden');
      document.getElementById('error').textContent = message;
      document.getElementById('error').classList.remove('hidden');
    }
    
    /**
     * Get authentication headers for API requests
     * Tries coach API key first, then event entry code, then match code
     */
    function getAuthHeaders(matchId = null, matchCode = null) {
      const headers = { 'Content-Type': 'application/json' };
      
      // Try coach API key first
      const coachKey = localStorage.getItem('coach_api_key') || localStorage.getItem('coach_passcode') || '';
      if (coachKey) {
        headers['X-API-Key'] = coachKey;
        headers['X-Passcode'] = coachKey;
        return headers;
      }
      
      // Fall back to event entry code
      const entryCode = localStorage.getItem('event_entry_code') || '';
      if (entryCode) {
        headers['X-Passcode'] = entryCode;
        return headers;
      }
      
      // Try match code (for standalone matches)
      if (matchCode) {
        headers['X-Passcode'] = matchCode;
        return headers;
      }
      
      // Try to get match code from localStorage if matchId provided
      if (matchId) {
        const storedMatchCode = localStorage.getItem(`solo_match_code:${matchId}`);
        if (storedMatchCode) {
          headers['X-Passcode'] = storedMatchCode;
          return headers;
        }
      }
      
      // No auth available - return headers without auth (may fail for protected endpoints)
      return headers;
    }

    /**
     * Show solo match scorecard in modal
     */
    async function showSoloMatchScorecard(match) {
      if (!match || !match.match_id) {
        console.error('Invalid match data:', match);
        alert('Unable to load match. Missing match ID.');
        return;
      }

      try {
        if (typeof SoloMatchView === 'undefined') {
          alert('Solo match viewer is not loaded. Please refresh the page.');
          return;
        }

        console.log('Loading solo match:', match.match_id);

        // Get match code from history data or localStorage
        const matchCode = match.match_code || localStorage.getItem(`solo_match_code:${match.match_id}`);
        
        // Store match code in localStorage if we got it from history (for future use)
        if (match.match_code && !localStorage.getItem(`solo_match_code:${match.match_id}`)) {
          localStorage.setItem(`solo_match_code:${match.match_id}`, match.match_code);
        }

        // Get authentication headers (includes match code if available)
        const headers = getAuthHeaders(match.match_id, matchCode);

        // Fetch complete match details from API
        const response = await fetch(`${API_BASE}/solo-matches/${match.match_id}`, {
          headers: headers
        });
        if (!response.ok) {
          if (response.status === 404) {
            alert('Match not found. This match may have been deleted.');
          } else if (response.status === 401) {
            alert('Authentication required. Please ensure you are logged in as a coach or have an event code.');
          } else {
            throw new Error(`HTTP ${response.status}`);
          }
          return;
        }

        const data = await response.json();
        const matchData = data.match;

        if (!matchData) {
          throw new Error('Invalid match data received');
        }

        console.log('Match data loaded:', matchData);

        // Build editUrl for Scorecard Editor (coach-only)
        let editUrl = null;
        if (match.match_id) {
          editUrl = `scorecard_editor.html?match=${match.match_id}&mode=coach`;
        }

        // Show modal with match details
        SoloMatchView.showMatchModal(matchData, {
          onRemake: () => {
            // Navigate to solo card for remake
            window.location.href = `solo_card.html?match=${match.match_id}`;
          },
          editUrl: editUrl
        });
      } catch (error) {
        console.error('Error loading solo match:', error);
        alert('Unable to load match details: ' + error.message + '\n\nCheck console for details.');
      }
    }

    async function showRoundScorecard(round) {
      // Fetch detailed scorecard data from API
      try {
        if (typeof ScorecardView === 'undefined') {
          alert('Scorecard viewer is not loaded. Please refresh the page.');
          return;
        }
        
        console.log('Round data received:', round);
        
        // Extract the correct field names (API might return different field names)
        const roundId = round.round_id || round.roundId || round.id;
        const archerIdForRequest = round.archer_id || round.archerId;
        
        // Check if we need to fetch from API or if we have the data already
        if (!roundId || !archerIdForRequest) {
          console.error('Missing round or archer information. Round data:', round);
          alert('Missing round or archer information. Round ID: ' + roundId + ', Archer ID: ' + archerIdForRequest);
          return;
        }
        
        console.log('Fetching scorecard for round:', roundId, 'archer:', archerIdForRequest);
        const res = await fetch(`${API_BASE}/rounds/${roundId}/archers/${archerIdForRequest}/scorecard`);
        if (!res.ok) {
          if (res.status === 404) {
            alert('Scorecard not found. This round may not have been scored yet.');
          } else {
            alert(`Unable to load scorecard details (HTTP ${res.status})`);
          }
          return;
        }
        
        const scorecardData = await res.json();
        console.log('Scorecard data:', scorecardData);
        
        // Extract scores from ends
        const scores = (scorecardData.ends || []).map(end => [
          end.a1 || '',
          end.a2 || '',
          end.a3 || ''
        ]);
        
        // Use globally stored archer data for name and details
        // Pass cardStatus from round data (history API) or scorecardData (scorecard API)
        // This ensures the status badge matches what's shown in the list
        const archerData = {
          id: round.archer_id,
          firstName: currentArcherData ? currentArcherData.firstName : '',
          lastName: currentArcherData ? currentArcherData.lastName : '',
          school: currentArcherData ? currentArcherData.school : '',
          level: currentArcherData ? currentArcherData.level : '',
          gender: currentArcherData ? currentArcherData.gender : '',
          scores: scores,
          cardStatus: round.card_status || scorecardData.card_status || (scorecardData.verified ? 'VER' : (scorecardData.ends_completed >= 10 ? 'COMP' : 'PENDING')),
          verified: scorecardData.verified || false,
          completed: (scorecardData.ends_completed >= 10)
        };
        
        const roundData = {
          totalEnds: 10,
          eventName: round.event_name || '',
          division: round.division || '',
          roundType: round.round_type || 'R300'
        };
        
        // Build editUrl for Scorecard Editor (coach-only)
        // roundArcherId might be in round object or scorecardData
        let editUrl = null;
        const roundArcherId = round.round_archer_id || round.roundArcherId || scorecardData.roundArcherId || scorecardData.id;
        if (roundArcherId) {
          editUrl = `scorecard_editor.html?id=${roundArcherId}&mode=coach`;
        }
        
        ScorecardView.showScorecardModal(archerData, roundData, { editUrl });
      } catch (err) {
        console.error('Error loading scorecard:', err);
        alert('Error loading scorecard: ' + err.message + '\n\nCheck console for details.');
      }
    }

    async function deleteScorecard(roundId, roundArcherId, eventName, buttonElement) {
      if (!confirm(`Delete this abandoned scorecard from "${eventName}"?\n\nThis action cannot be undone.`)) {
        return;
      }
      
      try {
        // Disable button during request
        buttonElement.disabled = true;
        buttonElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
        
        // Check if current user is the owner of this scorecard
        const isOwner = currentArcherData && currentArcherData.id === archerId;
        
        let headers = {
          'Content-Type': 'application/json'
        };
        
        if (isOwner) {
          // Archer deleting their own scorecard - use archer authentication
          headers['X-Archer-ID'] = archerId;
          headers['X-Archer-Self'] = 'true';
        } else {
          // Coach or other user - use coach credentials
          const coachApiKey = localStorage.getItem('coach_api_key') || 
                             localStorage.getItem('coach_passcode') || 
                             getCookie('coach_auth') || 
                             'wdva26'; // Default coach passcode
          
          headers['X-Passcode'] = coachApiKey;
          headers['X-API-Key'] = coachApiKey;
        }
        
        const response = await fetch(`${API_BASE}/rounds/${roundId}/archers/${roundArcherId}`, {
          method: 'DELETE',
          headers: headers
        });
        
        if (!response.ok) {
          if (response.status === 401 || response.status === 403) {
            if (isOwner) {
              throw new Error('You can only delete your own abandoned scorecards. Make sure you have set yourself in the Archer Details.');
            } else {
              throw new Error('Authentication required. Please visit the Coach Console to authenticate first, then try again.');
            }
          }
          const errorText = await response.text().catch(() => 'Unknown error');
          throw new Error(`Failed to delete scorecard (HTTP ${response.status}): ${errorText}`);
        }
        
        const result = await response.json();
        if (result.ok) {
          alert('Scorecard deleted successfully!');
          // Reload the history to reflect changes
          loadHistory();
        } else {
          throw new Error(result.error || 'Delete failed');
        }
      } catch (error) {
        console.error('Delete scorecard error:', error);
        alert('Failed to delete scorecard: ' + error.message);
        
        // Re-enable button on error
        buttonElement.disabled = false;
        buttonElement.innerHTML = '<i class="fas fa-trash-alt"></i>';
      }
    }
    
    // Helper function to get cookie value
    function getCookie(name) {
      const nameEQ = name + '=';
      const ca = document.cookie.split(';');
      for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
      }
      return null;
    }

    // Load history on page load
    document.addEventListener('DOMContentLoaded', () => {
      loadHistory();
    });
  </script>
</body>
</html>

