<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Practice Target</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/tailwind-compiled.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="js/archer_module.js"></script>
</head>
<body class="practice-target-page bg-gray-50 dark:bg-gray-900">

    <div id="app-container" class="main-container flex flex-col h-screen">
        <header class="page-header bg-white dark:bg-gray-800 shadow-sm p-3">
            <div class="flex items-center justify-between">
                <h1 class="text-xl font-bold text-gray-800 dark:text-white">Practice Target</h1>
                <div id="archer-info" class="text-sm text-gray-600 dark:text-gray-400 hidden">
                    <span id="archer-name-display">-</span>
                </div>
            </div>
        </header>

        <div class="page-controls bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-2 flex gap-2 flex-wrap justify-center" style="position: relative; z-index: 10;">
            <button id="correct-btn" class="btn btn-secondary text-xs sm:text-sm px-3 py-2 min-h-[44px]" style="pointer-events: auto; position: relative; z-index: 11;"><i class="fas fa-edit"></i> <span class="hidden sm:inline">Correct</span></button>
            <button id="rescore-btn" class="btn btn-secondary text-xs sm:text-sm px-3 py-2 min-h-[44px] hidden" style="pointer-events: auto; position: relative; z-index: 11;"><i class="fas fa-bullseye"></i> <span class="hidden sm:inline">Rescore</span></button>
            <button id="save-btn" class="btn btn-primary text-xs sm:text-sm px-3 py-2 min-h-[44px] hidden" style="pointer-events: auto; position: relative; z-index: 11;"><i class="fas fa-save"></i> <span class="hidden sm:inline">Save</span></button>
            <button id="save-image-btn" class="btn btn-secondary text-xs sm:text-sm px-3 py-2 min-h-[44px] hidden" style="pointer-events: auto; position: relative; z-index: 11;"><i class="fas fa-download"></i> <span class="hidden sm:inline">Image</span></button>
        </div>

        <div id="canvas-container" style="line-height: 0; flex-grow: 1; display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative;">
            <!-- p5.js canvas will be inserted here -->
        </div>
        
        <footer class="global-footer fixed bottom-0 left-0 right-0 h-[36px] bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 flex items-center px-4 z-10 safe-bottom shadow-lg transition-colors duration-200">
            <a href="index.html" class="pl-6 h-[44px] text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors flex items-center justify-center" aria-label="Home">
                <i class="fas fa-home text-xl"></i>
            </a>
            <div class="flex-1"></div>
            <button id="setup-btn" class="px-2 py-[2px] h-[44px] bg-primary text-white rounded font-semibold text-xs sm:text-sm transition-colors flex items-center justify-center"><i class="fas fa-cog mr-1"></i> <span class="hidden sm:inline">Setup</span></button>
        </footer>
    </div>

     <script>   
    // --- API Configuration ---
    const API_BASE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
        ? `${window.location.protocol}//${window.location.hostname}:${window.location.port || 8001}/api/index.php/v1`
        : 'https://tryentist.com/wdv/api/v1';

    // --- Configuration ---
    let arrowsPerEnd = 3;
    let numEnds = 6;
    let targetX, targetY;
    let targetRadius;
    const ringColors = [ // Colors remain the same
      [255, 255, 255], [255, 255, 255], [0, 0, 0], [0, 0, 0],
      [100, 150, 255], [100, 150, 255], [255, 80, 80], [255, 80, 80],
      [255, 255, 100], [255, 255, 100],
    ];
    const ringScores = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let ringRadii = [];
    let xRingRadius;
    const xRingInputFactor = 0.65;

    // --- Match State ---
    let matchData = []; // Now stores { score, value, x, y, end, arrowInEnd, displayX, displayY }
    let currentEnd = 1;
    let currentArrowInEnd = 1;
    let matchOver = false;
    let displayMode = 'actual'; // 'actual' or 'centered'

    // --- Correction State ---
    let isCorrectionMode = false;
    let correctionEndIndex = -1; // 0-based
    let correctionArrowIndex = -1; // 0-based
    let correctionEndNumber = -1; // 1-based (for display)
    let correctionArrowNumber = -1; // 1-based (for display)

    // --- End of Match Stats & Analysis ---
    let totalScore = 0; let numXs = 0; let numTens = 0;
    let avgX = 0; let avgY = 0; let totalArrowsShot = 0;
    let biasDescription = "";
    let hypotheticalScore = null;
    
    // --- Archer State ---
    let selectedArcher = null;
    
    // --- UI Elements (now references to DOM elements) ---
    let setupButton, correctButton, rescoreButton, saveButton, saveImageButton;
    let canvasContainer;

    // =================== SETUP ===================
    function setup() {
        canvasContainer = document.getElementById('canvas-container');
        if (!canvasContainer) {
            console.error('Canvas container not found');
            return;
        }
        
        // Get initial dimensions
        const initialWidth = canvasContainer.offsetWidth || window.innerWidth;
        const initialHeight = canvasContainer.offsetHeight || window.innerHeight;
        
        let cnv = createCanvas(initialWidth, initialHeight);
        cnv.parent('canvas-container');
        
        // Initialize button handlers after DOM is ready
        initializeButtonHandlers();
        
        // Add resize listener now that setup is complete
        addResizeListener();
        
        // Initial sizing
        handleResize();
        
        textAlign(LEFT, TOP);
        textSize(16);
        noStroke();
        
        initializeMatchData(false);
    }

    // Track if handlers are already initialized to prevent duplicates
    let handlersInitialized = false;

    // Initialize button handlers separately to ensure DOM is ready
    function initializeButtonHandlers() {
        // Prevent duplicate initialization
        if (handlersInitialized) {
            console.log('Button handlers already initialized, skipping...');
            return;
        }

        // Get UI elements
        setupButton = document.getElementById('setup-btn');
        correctButton = document.getElementById('correct-btn');
        rescoreButton = document.getElementById('rescore-btn');
        saveButton = document.getElementById('save-btn');
        saveImageButton = document.getElementById('save-image-btn');

        console.log('Initializing button handlers...', {
            setupButton: !!setupButton,
            correctButton: !!correctButton,
            saveButton: !!saveButton
        });

        // Test: Add a simple click listener to see if ANY clicks are detected
        document.body.addEventListener('click', (e) => {
            if (e.target.closest('button')) {
                console.log('Button clicked detected on body:', e.target.id || e.target.className);
            }
        }, true); // Use capture phase

        // Set up event handlers with null checks using addEventListener for better reliability
        if (setupButton) {
            setupButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Setup button clicked - handler fired!');
                configureAndResetMatch();
            }, { once: false, passive: false });
            console.log('Setup button handler attached, element:', setupButton);
        } else {
            console.warn('Setup button not found');
        }

        if (correctButton) {
            correctButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Correct button clicked - handler fired!');
                startCorrection();
            }, { once: false, passive: false });
            console.log('Correct button handler attached, element:', correctButton);
        }

        if (rescoreButton) {
            rescoreButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Rescore button clicked - handler fired!');
                toggleCenteredView();
            }, { once: false, passive: false });
            console.log('Rescore button handler attached, element:', rescoreButton);
        }

        if (saveButton) {
            saveButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Save button clicked - handler fired!');
                saveToDatabase();
            }, { once: false, passive: false });
            console.log('Save button handler attached, element:', saveButton);
        }

        if (saveImageButton) {
            saveImageButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Save image button clicked - handler fired!');
                saveScorecardImage();
            }, { once: false, passive: false });
            console.log('Save image button handler attached, element:', saveImageButton);
        }

        
        // Load archer selection
        loadArcherSelection();
        
        handlersInitialized = true;
        console.log('All button handlers initialized successfully');
    }
    
    function handleResize() {
        // Ensure canvasContainer is available
        if (!canvasContainer) {
            canvasContainer = document.getElementById('canvas-container');
            if (!canvasContainer) {
                console.warn('Canvas container not found in handleResize');
                return;
            }
        }

        const header = document.querySelector('.page-header');
        const controls = document.querySelector('.page-controls');
        const footer = document.querySelector('.global-footer');
        
        const headerHeight = header ? header.offsetHeight : 0;
        const controlsHeight = controls ? controls.offsetHeight : 0;
        const footerHeight = footer ? footer.offsetHeight : 0;

        // For debugging layout issues
        console.log(`Header: ${headerHeight}, Controls: ${controlsHeight}, Footer: ${footerHeight}`);

        const availableHeight = window.innerHeight - headerHeight - controlsHeight - footerHeight; // Use all available vertical space
        const availableWidth = canvasContainer ? canvasContainer.offsetWidth : window.innerWidth;
        
        if (availableWidth <= 0 || availableHeight <= 0) {
            console.warn('Invalid canvas dimensions:', availableWidth, availableHeight);
            return;
        }
        
        console.log(`Available WxH: ${availableWidth} x ${availableHeight}`);
        
        // Only resize if canvas exists
        if (typeof resizeCanvas === 'function') {
            resizeCanvas(availableWidth, availableHeight);
        }

        // Only update target if width/height are available
        if (typeof width !== 'undefined' && typeof height !== 'undefined') {
            targetRadius = min(width, height) * 0.4; // Reduced to give more top/bottom margin
            targetX = width / 2; // Center horizontally
            targetY = height / 2; // Center vertically

            calculateRadii();
            if(!isLooping() && typeof redraw === 'function') redraw();
        }
    }
    
    // Only add resize listener after setup is complete
    let resizeListenerAdded = false;
    function addResizeListener() {
        if (!resizeListenerAdded) {
            window.addEventListener('resize', handleResize);
            resizeListenerAdded = true;
        }
    }
    
    // Ensure button handlers are initialized when DOM is ready
    // p5.js setup() runs automatically, but we also want to ensure handlers are set
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initializeButtonHandlers, 200);
        });
    } else {
        // DOM already loaded, initialize after a short delay to ensure p5.js is ready
        setTimeout(initializeButtonHandlers, 200);
    }

    // =================== CONFIG, RESET, CORRECTION ===================
    function configureAndResetMatch() {
        let inputArrows = prompt(`Enter number of arrows per end:`, arrowsPerEnd); 
        let inputEnds = prompt(`Enter number of ends:`, numEnds);
        let newArrowsPerEnd = parseInt(inputArrows); 
        if (!isNaN(newArrowsPerEnd) && newArrowsPerEnd > 0) arrowsPerEnd = newArrowsPerEnd;
        let newNumEnds = parseInt(inputEnds); 
        if (!isNaN(newNumEnds) && newNumEnds > 0) numEnds = newNumEnds;
        isCorrectionMode = false; 
        correctionEndIndex = -1; 
        correctionArrowIndex = -1;
        initializeMatchData(true);
    }
    
    function initializeMatchData(logReset = true) {
        matchData = []; 
        for (let i = 0; i < numEnds; i++) {
            matchData.push([]);
        }
        currentEnd = 1; 
        currentArrowInEnd = 1; 
        matchOver = false; 
        isCorrectionMode = false;
        totalScore = 0; numXs = 0; numTens = 0; 
        avgX = 0; avgY = 0; totalArrowsShot = 0; 
        biasDescription = "";
        hypotheticalScore = null; 
        displayMode = 'actual';
        
        if (saveButton) saveButton.classList.add('hidden');
        if (saveImageButton) saveImageButton.classList.add('hidden');
        if (rescoreButton) { 
            rescoreButton.classList.add('hidden'); 
            rescoreButton.innerHTML = '<i class="fas fa-bullseye"></i> <span class="hidden sm:inline">Rescore Centered</span>';
        }
        if (correctButton) correctButton.classList.remove('btn-danger');

        if (logReset) console.log(`Match Reset: ${numEnds} ends, ${arrowsPerEnd} arrows per end.`);
        
        if (typeof draw === 'function' && typeof width !== 'undefined' && width > 0) { 
            loop(); 
            redraw(); 
        }
    }

     function startCorrection() {
        if (isCorrectionMode) { 
            isCorrectionMode = false; 
            correctButton.classList.remove('btn-danger');
            redraw(); 
            alert("Correction mode cancelled."); 
            return; 
        }
        let endNumStr = prompt(`Enter End # to correct (1-${numEnds}):`); if (endNumStr === null) return; 
        let endNum = parseInt(endNumStr);
        let arrowNumStr = prompt(`Enter Arrow # in End to correct (1-${arrowsPerEnd}):`); if (arrowNumStr === null) return; 
        let arrowNum = parseInt(arrowNumStr);
        let tempEndIndex = endNum - 1; 
        let tempArrowIndex = arrowNum - 1;
        
        if (isNaN(endNum) || tempEndIndex < 0 || tempEndIndex >= numEnds || isNaN(arrowNum) || tempArrowIndex < 0 || tempArrowIndex >= arrowsPerEnd) { 
            alert("Invalid End or Arrow number."); 
            return; 
        }
        if (!matchData[tempEndIndex] || tempArrowIndex >= matchData[tempEndIndex].length) { 
            alert(`Arrow ${arrowNum} in End ${endNum} has not been shot yet.`); 
            return; 
        }
        isCorrectionMode = true; 
        correctionEndIndex = tempEndIndex; 
        correctionArrowIndex = tempArrowIndex;
        correctionEndNumber = endNum; 
        correctionArrowNumber = arrowNum;
        correctButton.classList.add('btn-danger');
        alert(`Click on the target to enter the new score and position for End ${endNum}, Arrow ${arrowNum}.`); 
        loop(); 
        redraw();
    }

    // =================== CORE DRAWING & LOGIC ===================
    function calculateRadii() {
      ringRadii = []; 
      let ringWidth = targetRadius / 10; 
      if (targetRadius <= 0) return;
      for (let i = 0; i < 10; i++) { 
          let r = (i + 1) * ringWidth; 
          ringRadii.push(r); 
      }
      if (ringRadii.length > 0) { 
          xRingRadius = (ringRadii[0] / 2) * xRingInputFactor; 
      } else { 
          xRingRadius = 0; 
      }
    }

    function draw() {
        clear();
        background(240, 242, 245);

        // --- Draw graphical elements first (background layer) ---
        drawTarget();
        drawArrowMarkers();
        if (matchOver && totalArrowsShot > 0 && !isCorrectionMode && displayMode === 'actual') {
            drawAveragePosition();
        }

        // --- Draw text overlays (top layer) ---
        if (matchOver) {
            // After the match, show final totals at the top.
            displayMatchTotals();
        } else {
            // During the match, show the current shooting status.
            displayCurrentStatus();
        }
        
        // The end-by-end scoreboard is always displayed at the bottom.
        displayScoreboard();
    }

    function getScore(x, y) {
        let d = dist(x, y, targetX, targetY); 
        if (d <= xRingRadius) return 'X';
        if (!ringRadii || ringRadii.length !== 10) return 0;
        for (let i = 0; i < 10; i++) { 
            if (d <= ringRadii[i]) return 10 - i; 
        } 
        return 0;
    }

    function processShot(shotX, shotY) {
        if (shotY < 0 || shotY > height || shotX < 0 || shotX > width) return;

        if (isCorrectionMode) {
            let d = dist(shotX, shotY, targetX, targetY);
            if (d <= targetRadius) {
                let score = getScore(shotX, shotY);
                if (score !== 0) {
                    let arrowToCorrect = matchData[correctionEndIndex][correctionArrowIndex];
                    arrowToCorrect.score = score; 
                    arrowToCorrect.value = (score === 'X' ? 10 : score);
                    arrowToCorrect.x = shotX; 
                    arrowToCorrect.y = shotY;
                    arrowToCorrect.displayX = shotX; 
                    arrowToCorrect.displayY = shotY;
                    isCorrectionMode = false;
                    correctButton.classList.remove('btn-danger');
                    correctionEndIndex = -1; 
                    correctionArrowIndex = -1;
                    recalculateAllStats(); 
                    hypotheticalScore = null; 
                    displayMode = 'actual';
                    rescoreButton.innerHTML = '<i class="fas fa-bullseye"></i> Rescore Centered';
                    if (matchOver) {
                        noLoop();
                        redraw();
                    }
                } else { alert("Correction click missed the scoring area..."); }
            } else { alert("Correction click missed the target..."); }
            return;
        }

        if (matchOver) return;

        let d_norm = dist(shotX, shotY, targetX, targetY);
        if (d_norm <= targetRadius) {
            let score_norm = getScore(shotX, shotY);
            if (score_norm !== 0) {
                let arrowData = { 
                    score: score_norm, 
                    value: (score_norm === 'X' ? 10 : score_norm), 
                    x: shotX, y: shotY, displayX: shotX, displayY: shotY, 
                    end: currentEnd, 
                    arrowInEnd: currentArrowInEnd 
                };
                if (!matchData[currentEnd - 1]) matchData[currentEnd - 1] = [];
                matchData[currentEnd - 1].push(arrowData); 
                currentArrowInEnd++;
                if (currentArrowInEnd > arrowsPerEnd) {
                    currentEnd++; 
                    currentArrowInEnd = 1;
                    if (currentEnd > numEnds) {
                        matchOver = true; 
                        console.log("Match Over. Calculating final stats..."); 
                        recalculateAllStats();
                        if (saveButton) saveButton.classList.remove('hidden'); 
                        if (saveImageButton) saveImageButton.classList.remove('hidden');
                        if (rescoreButton) rescoreButton.classList.remove('hidden');
                        noLoop(); 
                        redraw();
                    }
                }
            }
        }
    }
    
    function mousePressed() {
        processShot(mouseX, mouseY);
    }
    
    function touchStarted() {
        if (touches.length > 0) {
            const touch = touches[0];
            const touchX = touch.x;
            const touchY = touch.y;
            
            // Check if touch is on an interactive element (button, link, etc.)
            // This prevents the canvas from blocking button clicks when match is over
            const elementAtPoint = document.elementFromPoint(touchX, touchY);
            if (elementAtPoint) {
                const isInteractive = elementAtPoint.closest('button, a, input, select, textarea');
                if (isInteractive) {
                    // Allow touch to pass through to button/link
                    return true;
                }
            }
            
            // If match is over and touch is outside target area, allow default behavior
            // This enables button clicks even when touching near buttons
            if (matchOver) {
                const d = dist(touchX, touchY, targetX, targetY);
                if (d > targetRadius) {
                    // Touch is outside target area, allow default behavior (enables button clicks)
                    return true;
                }
            }
            
            // Process shot for touches on the target area
            processShot(touchX, touchY);
            // prevent default browser actions like scrolling or zooming on touch devices, crucial for iOS Safari.
            return false;
        }
        return true;
    }

    // =================== STATS RECALCULATION & ANALYSIS ===================
    function recalculateAllStats() { 
        totalScore = 0; numXs = 0; numTens = 0; 
        let sumX = 0; let sumY = 0; totalArrowsShot = 0;
        if (!matchData || !Array.isArray(matchData)) { 
            biasDescription = "Error calculating stats."; return; 
        }
        for (let endArr of matchData) { 
            if (!endArr || !Array.isArray(endArr)) continue; 
            for (let arrow of endArr) { 
                if (!arrow || typeof arrow.value === 'undefined' || typeof arrow.score === 'undefined' || typeof arrow.x === 'undefined' || typeof arrow.y === 'undefined') continue; 
                totalScore += arrow.value; 
                if (arrow.score === 'X') numXs++; 
                if (arrow.score === 10) numTens++; 
                sumX += arrow.x; 
                sumY += arrow.y; 
                totalArrowsShot++; 
            } 
        }
        if (totalArrowsShot > 0) { 
            avgX = sumX / totalArrowsShot; 
            avgY = sumY / totalArrowsShot; 
            analyzeBias(avgX, avgY); 
        } else { 
            avgX = targetX; 
            avgY = targetY; 
            biasDescription = "No arrows shot."; 
        }
    }

    function analyzeBias(ax, ay) { 
        let deltaX = ax - targetX; 
        let deltaY = ay - targetY; 
        let threshold = targetRadius / 10; 
        let biasParts = [];
        if (deltaY < -threshold) biasParts.push("High"); 
        else if (deltaY > threshold) biasParts.push("Low"); 
        if (deltaX < -threshold) biasParts.push("Left"); 
        else if (deltaX > threshold) biasParts.push("Right");
        if (biasParts.length === 0) biasDescription = "Group centered well."; 
        else biasDescription = "Group centered: " + biasParts.join(" and ") + ".";
    }
    
    function calculateCenteredScoreAndPositions() {
        recalculateAllStats();

        if (!matchData || totalArrowsShot === 0) {
             alert("No arrows have been shot yet.");
             hypotheticalScore = null; return false;
        }
        let centeredTotal = 0;
        let offsetX = targetX - avgX; 
        let offsetY = targetY - avgY;

        for (let i = 0; i < matchData.length; i++) {
            let endArr = matchData[i]; if (!endArr || !Array.isArray(endArr)) continue;
            for (let j = 0; j < endArr.length; j++) {
                let arrow = endArr[j]; 
                if (!arrow || typeof arrow.x === 'undefined' || typeof arrow.y === 'undefined') continue;
                arrow.displayX = arrow.x + offsetX; 
                arrow.displayY = arrow.y + offsetY;
                let distFromCenter = dist(arrow.displayX, arrow.displayY, targetX, targetY);
                let centeredScoreValue = 0;
                if (distFromCenter <= xRingRadius) { centeredScoreValue = 10; }
                else if (ringRadii && ringRadii.length === 10) { 
                    for (let k = 0; k < 10; k++) { 
                        if (distFromCenter <= ringRadii[k]) { 
                            centeredScoreValue = 10 - k; break; 
                        } 
                    } 
                }
                centeredTotal += centeredScoreValue;
            }
        }
        hypotheticalScore = centeredTotal;
        return true;
    }

    function toggleCenteredView() {
        if (!matchOver) return;
        if (displayMode === 'actual') {
            let success = calculateCenteredScoreAndPositions();
            if (success) { 
                displayMode = 'centered'; 
                rescoreButton.innerHTML = '<i class="fas fa-crosshairs"></i> Show Actual Plot';
            }
        } else {
            displayMode = 'actual'; 
            rescoreButton.innerHTML = '<i class="fas fa-bullseye"></i> Rescore Centered';
        }
        if (matchOver) {
            noLoop(); 
            redraw();
        }
    }

    // =================== DRAWING HELPERS ===================
     function drawTarget() {
        push(); 
        translate(targetX, targetY); 
        noStroke(); 
        if (!ringRadii || ringRadii.length !== 10) { pop(); return; }
        fill(ringColors[0]); ellipse(0, 0, targetRadius * 2); 
        fill(ringColors[2]); ellipse(0, 0, ringRadii[7] * 2); 
        fill(ringColors[4]); ellipse(0, 0, ringRadii[5] * 2); 
        fill(ringColors[6]); ellipse(0, 0, ringRadii[3] * 2); 
        fill(ringColors[8]); ellipse(0, 0, ringRadii[1] * 2);
        strokeWeight(1); noFill(); 
        for (let i = 0; i < 9; i++) { 
            stroke(i === 5 ? 255 : 0); 
            ellipse(0, 0, ringRadii[i] * 2); 
        } 
        stroke(0); 
        ellipse(0, 0, xRingRadius * 2); 
        pop();
    }
    
    function drawArrowMarkers() {
      push(); 
      if (!matchData || !Array.isArray(matchData)) return;
      for (let endArr of matchData) { 
          if (!endArr || !Array.isArray(endArr)) continue; 
          for (let arrow of endArr) { 
              if (!arrow || typeof arrow.x === 'undefined' || typeof arrow.y === 'undefined') continue; 
              let drawX, drawY; 
              if (displayMode === 'centered' && typeof arrow.displayX !== 'undefined') { 
                  drawX = arrow.displayX; 
                  drawY = arrow.displayY; 
                  fill(255, 0, 0, 180); 
                  stroke(255); 
                  strokeWeight(1); 
                  ellipse(drawX, drawY, 9, 9); 
                } else { 
                    drawX = arrow.x; 
                    drawY = arrow.y; 
                    fill(0, 0, 0, 200); 
                    noStroke(); 
                    ellipse(drawX, drawY, 8, 8); 
                } 
            } 
        } 
        pop();
    }
    
    function drawAveragePosition() {
        push(); 
        let dotSize = 15; 
        noStroke(); 
        fill(255, 0, 0, 180); 
        ellipse(avgX, avgY, dotSize); 
        strokeWeight(1); 
        noFill(); 
        stroke(0); 
        ellipse(avgX, avgY, dotSize); 
        stroke(255); 
        ellipse(avgX, avgY, dotSize + 2); 
        pop();
    }
    
    function displayScoreboard() {
        push();
        const scoreX = width / 2;
        const lineHeight = 20;
        const titleHeight = 25;
        const bottomPadding = 15;
        const biasHeight = matchOver ? 30 : 0; // Space for bias text if needed

        const totalBlockHeight = titleHeight + (numEnds * lineHeight) + biasHeight + bottomPadding;
        let currentY = height - totalBlockHeight;

        // --- Draw Title ---
        textAlign(CENTER, TOP);
        textFont('monospace');
        textStyle(BOLD);
        textSize(14);
        fill(0);
        text("End Scores", scoreX, currentY);
        currentY += titleHeight;

        // --- Draw Score Rows ---
        textStyle(NORMAL);
        for (let i = 0; i < numEnds; i++) {
            if (!matchData[i]) matchData[i] = [];
            let endArrows = matchData[i];
            let endTotal = 0;
            for (let arrow of endArrows) {
                if (arrow && arrow.value) endTotal += arrow.value;
            }
            
            let displayRunningTotal = 0;
            for (let k = 0; k <= i; k++) {
                if (matchData[k] && Array.isArray(matchData[k])) {
                    for (let arrow of matchData[k]) {
                        if (arrow && arrow.value) displayRunningTotal += arrow.value;
                    }
                }
            }
            
            if (endArrows.length === 0 && (i + 1) > currentEnd && !matchOver) continue;
            
            let endScoreTexts = [];
            for (let j = 0; j < arrowsPerEnd; j++) {
                if (j < endArrows.length && endArrows[j] && endArrows[j].score) {
                    endScoreTexts.push(String(endArrows[j].score).padStart(2));
                } else {
                    endScoreTexts.push("  ");
                }
            }
            
            let scoreString = endScoreTexts.join(' ');
            let displayLine = `E${String(i + 1).padStart(2)}: ${scoreString} | ${String(endTotal).padStart(3)} | ${String(displayRunningTotal).padStart(4)}`;
            text(displayLine, scoreX, currentY + i * lineHeight);
        }
        
        // --- Draw Bias Analysis ---
        if (matchOver) {
            currentY += numEnds * lineHeight + 10;
            textSize(14);
            fill(50);
            text(biasDescription, scoreX, currentY);
        }
        
        pop();
    }

    function displayCurrentStatus() {
        push();
        fill(0);
        textAlign(CENTER, TOP);
        textSize(16);
        const statusX = width / 2;
        const statusY = 15;

        if (isCorrectionMode) {
            fill(255, 0, 0);
            text(`Correction Mode: Click target for End ${correctionEndNumber}, Arrow ${correctionArrowNumber}`, statusX, statusY);
        } else if (!matchOver) {
            let statusText = `Shooting End: ${currentEnd}/${numEnds}, Arrow: ${currentArrowInEnd}/${arrowsPerEnd}`;
            text(statusText, statusX, statusY);
        }
        pop();
    }

    function displayMatchTotals() {
        push();
        fill(0);
        textAlign(CENTER, TOP);
        textSize(16);
        const totalsY = 15; // Position text at the top
        const totalsX = width / 2;

        textStyle(BOLD);
        text(`Actual Score: ${totalScore} (${numXs} X's, ${numTens} 10's)`, totalsX, totalsY);

        if (hypotheticalScore !== null) {
            text(`Recenter Score: ${hypotheticalScore}`, totalsX, totalsY + 25);
        }
        pop();
    }

    // =================== ARCHER MANAGEMENT ===================
    function loadArcherSelection() {
        if (typeof ArcherModule === 'undefined') {
            console.warn('ArcherModule not available');
            return;
        }
        
        const selfArcher = ArcherModule.getSelfArcher();
        if (selfArcher) {
            selectedArcher = selfArcher;
            updateArcherDisplay();
        } else {
            // Prompt user to select their archer record
            promptArcherSelection();
        }
    }

    function promptArcherSelection() {
        if (typeof ArcherModule === 'undefined') {
            console.warn('ArcherModule not available for selection');
            return;
        }
        
        const roster = ArcherModule.loadList() || [];
        if (roster.length === 0) {
            console.warn('No archers in roster to select from');
            return;
        }
        
        // Build a list of archers for the prompt
        const archerList = roster.map((archer, index) => {
            const name = `${archer.first || ''} ${archer.last || ''}`.trim() || 'Unknown';
            const school = archer.school || '';
            const level = archer.level || '';
            return `${index + 1}. ${name} (${school} ${level})`;
        }).join('\n');
        
        const promptText = `Please select which archer you are:\n\n${archerList}\n\nEnter the number (1-${roster.length}):`;
        const selection = prompt(promptText);
        
        if (selection === null) {
            // User cancelled
            return;
        }
        
        const index = parseInt(selection) - 1;
        if (isNaN(index) || index < 0 || index >= roster.length) {
            alert('Invalid selection. Please refresh the page to try again.');
            return;
        }
        
        const selectedArcherFromList = roster[index];
        if (selectedArcherFromList) {
            selectedArcher = selectedArcherFromList;
            if (typeof ArcherModule !== 'undefined') {
                ArcherModule.setSelfArcher(selectedArcherFromList.extId);
            }
            updateArcherDisplay();
            console.log('Archer selected:', selectedArcherFromList.first, selectedArcherFromList.last);
        }
    }

    function updateArcherDisplay() {
        const archerInfo = document.getElementById('archer-info');
        const archerNameDisplay = document.getElementById('archer-name-display');
        
        if (selectedArcher) {
            const name = `${selectedArcher.first || ''} ${selectedArcher.last || ''}`.trim() || 'Unknown';
            archerNameDisplay.textContent = name;
            archerInfo.classList.remove('hidden');
        } else {
            archerInfo.classList.add('hidden');
        }
    }

    // =================== DATABASE SAVE ===================
    async function saveToDatabase() {
        if (!matchOver || totalArrowsShot === 0) {
            alert('No practice data to save. Complete the practice round first.');
            return;
        }

        if (!selectedArcher) {
            const proceed = confirm('No archer selected. Would you like to select one now?');
            if (proceed) {
                promptArcherSelection();
            }
            if (!selectedArcher) {
                alert('Archer selection is required to save practice rounds.');
                return;
            }
        }

        // Disable save button during save
        const originalText = saveButton.innerHTML;
        saveButton.disabled = true;
        saveButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span class="hidden sm:inline">Saving...</span>';

        try {
            // Get API key/passcode for practice rounds (use default passcode)
            const headers = { 'Content-Type': 'application/json' };
            const passcode = localStorage.getItem('coach_passcode') || localStorage.getItem('coach_api_key') || 'wdva26';
            headers['X-Passcode'] = passcode;

            // Create practice round
            const roundDate = new Date().toISOString().split('T')[0];
            const roundResponse = await fetch(`${API_BASE}/rounds`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    roundType: 'PRACTICE',
                    date: roundDate,
                    division: 'OPEN'
                })
            });

            if (!roundResponse.ok) {
                throw new Error(`Failed to create practice round: ${roundResponse.status}`);
            }

            const roundData = await roundResponse.json();
            const roundId = roundData.roundId;

            // Add archer to round
            const archerResponse = await fetch(`${API_BASE}/rounds/${roundId}/archers`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    archerId: selectedArcher.id || selectedArcher.extId,
                    archerName: `${selectedArcher.first || ''} ${selectedArcher.last || ''}`.trim(),
                    school: selectedArcher.school || 'UNK',
                    level: selectedArcher.level || 'VAR',
                    gender: selectedArcher.gender || 'M',
                    targetAssignment: 'A'
                })
            });

            if (!archerResponse.ok) {
                throw new Error(`Failed to add archer to round: ${archerResponse.status}`);
            }

            const archerData = await archerResponse.json();
            const roundArcherId = archerData.roundArcherId;

            // Save each end
            let runningTotal = 0;
            for (let endIndex = 0; endIndex < matchData.length; endIndex++) {
                const endArrows = matchData[endIndex] || [];
                if (endArrows.length === 0) continue;

                // Convert arrows to a1, a2, a3 format
                const a1 = endArrows[0] ? (endArrows[0].score === 'X' ? 'X' : String(endArrows[0].score)) : null;
                const a2 = endArrows[1] ? (endArrows[1].score === 'X' ? 'X' : String(endArrows[1].score)) : null;
                const a3 = endArrows[2] ? (endArrows[2].score === 'X' ? 'X' : String(endArrows[2].score)) : null;

                // Calculate end totals
                let endTotal = 0;
                let tens = 0;
                let xs = 0;
                [a1, a2, a3].forEach(arrow => {
                    if (!arrow) return;
                    const upper = String(arrow).toUpperCase();
                    if (upper === 'X') {
                        endTotal += 10;
                        xs++;
                        tens++;
                    } else if (upper === '10') {
                        endTotal += 10;
                        tens++;
                    } else {
                        const val = parseInt(arrow);
                        if (!isNaN(val)) endTotal += Math.max(0, Math.min(10, val));
                    }
                });

                runningTotal += endTotal;

                // Save end (this endpoint is public, no auth needed)
                const endResponse = await fetch(`${API_BASE}/rounds/${roundId}/archers/${roundArcherId}/ends`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        endNumber: endIndex + 1,
                        a1: a1,
                        a2: a2,
                        a3: a3,
                        endTotal: endTotal,
                        runningTotal: runningTotal,
                        tens: tens,
                        xs: xs
                    })
                });

                if (!endResponse.ok) {
                    throw new Error(`Failed to save end ${endIndex + 1}: ${endResponse.status}`);
                }
            }

            alert(`Practice round saved successfully!\n\nScore: ${totalScore}\nXs: ${numXs}\n10s: ${numTens}\n\nView your history to see this practice round.`);
            
            // Optionally redirect to archer history
            if (selectedArcher.id || selectedArcher.extId) {
                const archerId = selectedArcher.id || selectedArcher.extId;
                const viewHistory = confirm('Would you like to view your archer history?');
                if (viewHistory) {
                    window.location.href = `archer_history.html?archer=${encodeURIComponent(archerId)}`;
                }
            }

        } catch (error) {
            console.error('Error saving practice round:', error);
            const errorMsg = error.message || 'Unknown error';
            if (errorMsg.includes('401') || errorMsg.includes('Unauthorized')) {
                alert(`Authentication required to save practice rounds.\n\nPlease contact your coach for access, or save as image instead.`);
            } else {
                alert(`Failed to save practice round: ${errorMsg}\n\nPlease try again or save as image instead.`);
            }
        } finally {
            saveButton.disabled = false;
            saveButton.innerHTML = originalText;
        }
    }

    // =================== IMAGE SAVE ===================
    function saveScorecardImage() {
        if (!matchOver || totalArrowsShot === 0) {
            alert('Complete the practice round before saving an image.');
            return;
        }

        // Save original display mode
        let originalDisplayMode = displayMode;
        
        // Switch to actual mode if in centered mode (for cleaner screenshot)
        if (displayMode === 'centered') {
            displayMode = 'actual';
        }

        // Force a redraw to ensure all elements (target, arrows, scores, text) are rendered
        redraw();

        // Wait a brief moment to ensure canvas is fully rendered before saving
        // This is critical - p5.js needs time to complete the draw() cycle
        setTimeout(() => {
            const d = new Date();
            const timestamp = `${d.getFullYear()}${nf(d.getMonth() + 1, 2)}${nf(d.getDate(), 2)}_${nf(d.getHours(), 2)}${nf(d.getMinutes(), 2)}${nf(d.getSeconds(), 2)}`;
            const filename = `PracticeTarget_${timestamp}.png`;
            
            // Use p5.js saveCanvas - this should capture everything drawn on the canvas
            // including target, arrow markers, scores, and all text
            saveCanvas(filename);
            
            // Restore original display mode if needed
            if (originalDisplayMode === 'centered') {
                displayMode = 'centered';
                redraw();
            }
        }, 150); // Small delay to ensure draw() has completed
    }
    
    </script>
   </body>
</html>
</html>